// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internal/bean/types.proto

package db

import (
	"go-cs/internal/bean"
	"google.golang.org/protobuf/proto"
)

const TableNamePrefix = ""

// This file was automatically generated by the types generator
// Input file: internal/bean/types.proto

// -----------------------------------------------------------------------------
// WorkItemRole 表结构
// 对应的 Proto 消息类型: WorkItemRole
// 数据库表名: work_item_role
type WorkItemRole struct {
	Id             int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Uuid           string `gorm:"column:uuid" bson:"uuid" json:"uuid"`
	UserId         int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId        int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkItemTypeId int64  `gorm:"column:work_item_type_id" bson:"work_item_type_id" json:"work_item_type_id"`
	Key            string `gorm:"column:key" bson:"key" json:"key"`
	Name           string `gorm:"column:name" bson:"name" json:"name"`
	Status         int64  `gorm:"column:status" bson:"status" json:"status"`
	Ranking        int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	IsSys          int32  `gorm:"column:is_sys" bson:"is_sys" json:"is_sys"`
	CreatedAt      int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt      int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt      int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	FlowScope      string `gorm:"column:flow_scope" bson:"flow_scope" json:"flow_scope"`
}

func (m *WorkItemRole) TableName() string {
	return TableNamePrefix + "work_item_role"
}

func (m *WorkItemRole) Cloumns() *workItemRoleCloumns {
	return _workItemRoleCloumns
}

func (m *WorkItemRole) ToProto() *bean.WorkItemRole {
	return &bean.WorkItemRole{
		Id:             int64(m.Id),
		Uuid:           string(m.Uuid),
		UserId:         int64(m.UserId),
		SpaceId:        int64(m.SpaceId),
		WorkItemTypeId: int64(m.WorkItemTypeId),
		Key:            string(m.Key),
		Name:           string(m.Name),
		Status:         int64(m.Status),
		Ranking:        int64(m.Ranking),
		IsSys:          int32(m.IsSys),
		CreatedAt:      int64(m.CreatedAt),
		UpdatedAt:      int64(m.UpdatedAt),
		DeletedAt:      int64(m.DeletedAt),
		FlowScope:      string(m.FlowScope),
	}
}

func (m *WorkItemRole) FromProto(proto *bean.WorkItemRole) {
	m.Id = int64(proto.Id)
	m.Uuid = string(proto.Uuid)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkItemTypeId = int64(proto.WorkItemTypeId)
	m.Key = string(proto.Key)
	m.Name = string(proto.Name)
	m.Status = int64(proto.Status)
	m.Ranking = int64(proto.Ranking)
	m.IsSys = int32(proto.IsSys)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.FlowScope = string(proto.FlowScope)

}

func (m *WorkItemRole) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_WORK_ITEM_ROLE),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *WorkItemRole) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.WorkItemRole{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type workItemRoleCloumns struct {
	ALL string

	Id             string
	Uuid           string
	UserId         string
	SpaceId        string
	WorkItemTypeId string
	Key            string
	Name           string
	Status         string
	Ranking        string
	IsSys          string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	FlowScope      string
	raw            []string
}

var _workItemRoleCloumns *workItemRoleCloumns = &workItemRoleCloumns{
	raw: []string{
		"id", "uuid", "user_id", "space_id", "work_item_type_id", "key", "name", "status", "ranking", "is_sys", "created_at", "updated_at", "deleted_at", "flow_scope",
	},
	ALL:            "*",
	Id:             "id",
	Uuid:           "uuid",
	UserId:         "user_id",
	SpaceId:        "space_id",
	WorkItemTypeId: "work_item_type_id",
	Key:            "key",
	Name:           "name",
	Status:         "status",
	Ranking:        "ranking",
	IsSys:          "is_sys",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	FlowScope:      "flow_scope",
}

func (c *workItemRoleCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *workItemRoleCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// WorkFlow 表结构
// 对应的 Proto 消息类型: WorkFlow
// 数据库表名: work_flow
type WorkFlow struct {
	Id             int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Uuid           string `gorm:"column:uuid" bson:"uuid" json:"uuid"`
	UserId         int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId        int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkItemTypeId int64  `gorm:"column:work_item_type_id" bson:"work_item_type_id" json:"work_item_type_id"`
	Name           string `gorm:"column:name" bson:"name" json:"name"`
	Key            string `gorm:"column:key" bson:"key" json:"key"`
	FlowMode       string `gorm:"column:flow_mode" bson:"flow_mode" json:"flow_mode"`
	Version        int32  `gorm:"column:version" bson:"version" json:"version"`
	LastTemplateId int64  `gorm:"column:last_template_id" bson:"last_template_id" json:"last_template_id"`
	Status         int64  `gorm:"column:status" bson:"status" json:"status"`
	Ranking        int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	CreatedAt      int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt      int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt      int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	IsSys          int32  `gorm:"column:is_sys" bson:"is_sys" json:"is_sys"`
}

func (m *WorkFlow) TableName() string {
	return TableNamePrefix + "work_flow"
}

func (m *WorkFlow) Cloumns() *workFlowCloumns {
	return _workFlowCloumns
}

func (m *WorkFlow) ToProto() *bean.WorkFlow {
	return &bean.WorkFlow{
		Id:             int64(m.Id),
		Uuid:           string(m.Uuid),
		UserId:         int64(m.UserId),
		SpaceId:        int64(m.SpaceId),
		WorkItemTypeId: int64(m.WorkItemTypeId),
		Name:           string(m.Name),
		Key:            string(m.Key),
		FlowMode:       string(m.FlowMode),
		Version:        int32(m.Version),
		LastTemplateId: int64(m.LastTemplateId),
		Status:         int64(m.Status),
		Ranking:        int64(m.Ranking),
		CreatedAt:      int64(m.CreatedAt),
		UpdatedAt:      int64(m.UpdatedAt),
		DeletedAt:      int64(m.DeletedAt),
		IsSys:          int32(m.IsSys),
	}
}

func (m *WorkFlow) FromProto(proto *bean.WorkFlow) {
	m.Id = int64(proto.Id)
	m.Uuid = string(proto.Uuid)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkItemTypeId = int64(proto.WorkItemTypeId)
	m.Name = string(proto.Name)
	m.Key = string(proto.Key)
	m.FlowMode = string(proto.FlowMode)
	m.Version = int32(proto.Version)
	m.LastTemplateId = int64(proto.LastTemplateId)
	m.Status = int64(proto.Status)
	m.Ranking = int64(proto.Ranking)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.IsSys = int32(proto.IsSys)

}

func (m *WorkFlow) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_WORK_FLOW),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *WorkFlow) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.WorkFlow{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type workFlowCloumns struct {
	ALL string

	Id             string
	Uuid           string
	UserId         string
	SpaceId        string
	WorkItemTypeId string
	Name           string
	Key            string
	FlowMode       string
	Version        string
	LastTemplateId string
	Status         string
	Ranking        string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	IsSys          string
	raw            []string
}

var _workFlowCloumns *workFlowCloumns = &workFlowCloumns{
	raw: []string{
		"id", "uuid", "user_id", "space_id", "work_item_type_id", "name", "key", "flow_mode", "version", "last_template_id", "status", "ranking", "created_at", "updated_at", "deleted_at", "is_sys",
	},
	ALL:            "*",
	Id:             "id",
	Uuid:           "uuid",
	UserId:         "user_id",
	SpaceId:        "space_id",
	WorkItemTypeId: "work_item_type_id",
	Name:           "name",
	Key:            "key",
	FlowMode:       "flow_mode",
	Version:        "version",
	LastTemplateId: "last_template_id",
	Status:         "status",
	Ranking:        "ranking",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	IsSys:          "is_sys",
}

func (c *workFlowCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *workFlowCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// WorkFlowTemplate 表结构
// 对应的 Proto 消息类型: WorkFlowTemplate
// 数据库表名: work_flow_template
type WorkFlowTemplate struct {
	Id             int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Uuid           string `gorm:"column:uuid" bson:"uuid" json:"uuid"`
	UserId         int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId        int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkItemTypeId int64  `gorm:"column:work_item_type_id" bson:"work_item_type_id" json:"work_item_type_id"`
	WorkFlowId     int64  `gorm:"column:work_flow_id" bson:"work_flow_id" json:"work_flow_id"`
	FlowMode       string `gorm:"column:flow_mode" bson:"flow_mode" json:"flow_mode"`
	Version        int32  `gorm:"column:version" bson:"version" json:"version"`
	Setting        string `gorm:"column:setting" bson:"setting" json:"setting"`
	Status         int64  `gorm:"column:status" bson:"status" json:"status"`
	CreatedAt      int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt      int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt      int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *WorkFlowTemplate) TableName() string {
	return TableNamePrefix + "work_flow_template"
}

func (m *WorkFlowTemplate) Cloumns() *workFlowTemplateCloumns {
	return _workFlowTemplateCloumns
}

func (m *WorkFlowTemplate) ToProto() *bean.WorkFlowTemplate {
	return &bean.WorkFlowTemplate{
		Id:             int64(m.Id),
		Uuid:           string(m.Uuid),
		UserId:         int64(m.UserId),
		SpaceId:        int64(m.SpaceId),
		WorkItemTypeId: int64(m.WorkItemTypeId),
		WorkFlowId:     int64(m.WorkFlowId),
		FlowMode:       string(m.FlowMode),
		Version:        int32(m.Version),
		Setting:        string(m.Setting),
		Status:         int64(m.Status),
		CreatedAt:      int64(m.CreatedAt),
		UpdatedAt:      int64(m.UpdatedAt),
		DeletedAt:      int64(m.DeletedAt),
	}
}

func (m *WorkFlowTemplate) FromProto(proto *bean.WorkFlowTemplate) {
	m.Id = int64(proto.Id)
	m.Uuid = string(proto.Uuid)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkItemTypeId = int64(proto.WorkItemTypeId)
	m.WorkFlowId = int64(proto.WorkFlowId)
	m.FlowMode = string(proto.FlowMode)
	m.Version = int32(proto.Version)
	m.Setting = string(proto.Setting)
	m.Status = int64(proto.Status)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *WorkFlowTemplate) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_WORK_FLOW_TEMPLATE),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *WorkFlowTemplate) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.WorkFlowTemplate{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type workFlowTemplateCloumns struct {
	ALL string

	Id             string
	Uuid           string
	UserId         string
	SpaceId        string
	WorkItemTypeId string
	WorkFlowId     string
	FlowMode       string
	Version        string
	Setting        string
	Status         string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	raw            []string
}

var _workFlowTemplateCloumns *workFlowTemplateCloumns = &workFlowTemplateCloumns{
	raw: []string{
		"id", "uuid", "user_id", "space_id", "work_item_type_id", "work_flow_id", "flow_mode", "version", "setting", "status", "created_at", "updated_at", "deleted_at",
	},
	ALL:            "*",
	Id:             "id",
	Uuid:           "uuid",
	UserId:         "user_id",
	SpaceId:        "space_id",
	WorkItemTypeId: "work_item_type_id",
	WorkFlowId:     "work_flow_id",
	FlowMode:       "flow_mode",
	Version:        "version",
	Setting:        "setting",
	Status:         "status",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
}

func (c *workFlowTemplateCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *workFlowTemplateCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// WorkItemType 表结构
// 对应的 Proto 消息类型: WorkItemType
// 数据库表名: work_item_type
type WorkItemType struct {
	Id        int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Uuid      string `gorm:"column:uuid" bson:"uuid" json:"uuid"`
	UserId    int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId   int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	Name      string `gorm:"column:name" bson:"name" json:"name"`
	Key       string `gorm:"column:key" bson:"key" json:"key"`
	FlowMode  string `gorm:"column:flow_mode" bson:"flow_mode" json:"flow_mode"`
	Ranking   int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	Status    int64  `gorm:"column:status" bson:"status" json:"status"`
	CreatedAt int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	IsSys     int32  `gorm:"column:is_sys" bson:"is_sys" json:"is_sys"`
}

func (m *WorkItemType) TableName() string {
	return TableNamePrefix + "work_item_type"
}

func (m *WorkItemType) Cloumns() *workItemTypeCloumns {
	return _workItemTypeCloumns
}

func (m *WorkItemType) ToProto() *bean.WorkItemType {
	return &bean.WorkItemType{
		Id:        int64(m.Id),
		Uuid:      string(m.Uuid),
		UserId:    int64(m.UserId),
		SpaceId:   int64(m.SpaceId),
		Name:      string(m.Name),
		Key:       string(m.Key),
		FlowMode:  string(m.FlowMode),
		Ranking:   int64(m.Ranking),
		Status:    int64(m.Status),
		CreatedAt: int64(m.CreatedAt),
		UpdatedAt: int64(m.UpdatedAt),
		DeletedAt: int64(m.DeletedAt),
		IsSys:     int32(m.IsSys),
	}
}

func (m *WorkItemType) FromProto(proto *bean.WorkItemType) {
	m.Id = int64(proto.Id)
	m.Uuid = string(proto.Uuid)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.Name = string(proto.Name)
	m.Key = string(proto.Key)
	m.FlowMode = string(proto.FlowMode)
	m.Ranking = int64(proto.Ranking)
	m.Status = int64(proto.Status)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.IsSys = int32(proto.IsSys)

}

func (m *WorkItemType) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_WORK_ITEM_TYPE),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *WorkItemType) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.WorkItemType{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type workItemTypeCloumns struct {
	ALL string

	Id        string
	Uuid      string
	UserId    string
	SpaceId   string
	Name      string
	Key       string
	FlowMode  string
	Ranking   string
	Status    string
	CreatedAt string
	UpdatedAt string
	DeletedAt string
	IsSys     string
	raw       []string
}

var _workItemTypeCloumns *workItemTypeCloumns = &workItemTypeCloumns{
	raw: []string{
		"id", "uuid", "user_id", "space_id", "name", "key", "flow_mode", "ranking", "status", "created_at", "updated_at", "deleted_at", "is_sys",
	},
	ALL:       "*",
	Id:        "id",
	Uuid:      "uuid",
	UserId:    "user_id",
	SpaceId:   "space_id",
	Name:      "name",
	Key:       "key",
	FlowMode:  "flow_mode",
	Ranking:   "ranking",
	Status:    "status",
	CreatedAt: "created_at",
	UpdatedAt: "updated_at",
	DeletedAt: "deleted_at",
	IsSys:     "is_sys",
}

func (c *workItemTypeCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *workItemTypeCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// WorkItemStatus 表结构
// 对应的 Proto 消息类型: WorkItemStatus
// 数据库表名: work_item_status
type WorkItemStatus struct {
	Id             int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Uuid           string `gorm:"column:uuid" bson:"uuid" json:"uuid"`
	UserId         int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId        int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkItemTypeId int64  `gorm:"column:work_item_type_id" bson:"work_item_type_id" json:"work_item_type_id"`
	Name           string `gorm:"column:name" bson:"name" json:"name"`
	Key            string `gorm:"column:key" bson:"key" json:"key"`
	Val            string `gorm:"column:val" bson:"val" json:"val"`
	StatusType     int32  `gorm:"column:status_type" bson:"status_type" json:"status_type"`
	Ranking        int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	Status         int64  `gorm:"column:status" bson:"status" json:"status"`
	CreatedAt      int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt      int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt      int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	IsSys          int32  `gorm:"column:is_sys" bson:"is_sys" json:"is_sys"`
	FlowScope      string `gorm:"column:flow_scope" bson:"flow_scope" json:"flow_scope"`
}

func (m *WorkItemStatus) TableName() string {
	return TableNamePrefix + "work_item_status"
}

func (m *WorkItemStatus) Cloumns() *workItemStatusCloumns {
	return _workItemStatusCloumns
}

func (m *WorkItemStatus) ToProto() *bean.WorkItemStatus {
	return &bean.WorkItemStatus{
		Id:             int64(m.Id),
		Uuid:           string(m.Uuid),
		UserId:         int64(m.UserId),
		SpaceId:        int64(m.SpaceId),
		WorkItemTypeId: int64(m.WorkItemTypeId),
		Name:           string(m.Name),
		Key:            string(m.Key),
		Val:            string(m.Val),
		StatusType:     int32(m.StatusType),
		Ranking:        int64(m.Ranking),
		Status:         int64(m.Status),
		CreatedAt:      int64(m.CreatedAt),
		UpdatedAt:      int64(m.UpdatedAt),
		DeletedAt:      int64(m.DeletedAt),
		IsSys:          int32(m.IsSys),
		FlowScope:      string(m.FlowScope),
	}
}

func (m *WorkItemStatus) FromProto(proto *bean.WorkItemStatus) {
	m.Id = int64(proto.Id)
	m.Uuid = string(proto.Uuid)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkItemTypeId = int64(proto.WorkItemTypeId)
	m.Name = string(proto.Name)
	m.Key = string(proto.Key)
	m.Val = string(proto.Val)
	m.StatusType = int32(proto.StatusType)
	m.Ranking = int64(proto.Ranking)
	m.Status = int64(proto.Status)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.IsSys = int32(proto.IsSys)
	m.FlowScope = string(proto.FlowScope)

}

func (m *WorkItemStatus) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_WORK_ITEM_STATUS),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *WorkItemStatus) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.WorkItemStatus{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type workItemStatusCloumns struct {
	ALL string

	Id             string
	Uuid           string
	UserId         string
	SpaceId        string
	WorkItemTypeId string
	Name           string
	Key            string
	Val            string
	StatusType     string
	Ranking        string
	Status         string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	IsSys          string
	FlowScope      string
	raw            []string
}

var _workItemStatusCloumns *workItemStatusCloumns = &workItemStatusCloumns{
	raw: []string{
		"id", "uuid", "user_id", "space_id", "work_item_type_id", "name", "key", "val", "status_type", "ranking", "status", "created_at", "updated_at", "deleted_at", "is_sys", "flow_scope",
	},
	ALL:            "*",
	Id:             "id",
	Uuid:           "uuid",
	UserId:         "user_id",
	SpaceId:        "space_id",
	WorkItemTypeId: "work_item_type_id",
	Name:           "name",
	Key:            "key",
	Val:            "val",
	StatusType:     "status_type",
	Ranking:        "ranking",
	Status:         "status",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	IsSys:          "is_sys",
	FlowScope:      "flow_scope",
}

func (c *workItemStatusCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *workItemStatusCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// User 表结构
// 对应的 Proto 消息类型: User
// 数据库表名: user
type User struct {
	Id            int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserName      string `gorm:"column:user_name" bson:"user_name" json:"user_name"`
	Mobile        string `gorm:"column:mobile" bson:"mobile" json:"mobile"`
	UserNickname  string `gorm:"column:user_nickname" bson:"user_nickname" json:"user_nickname"`
	UserPinyin    string `gorm:"column:user_pinyin" bson:"user_pinyin" json:"user_pinyin"`
	UserPassword  string `gorm:"column:user_password" bson:"user_password" json:"user_password"`
	UserSalt      string `gorm:"column:user_salt" bson:"user_salt" json:"user_salt"`
	UserStatus    int32  `gorm:"column:user_status" bson:"user_status" json:"user_status"`
	UserEmail     string `gorm:"column:user_email" bson:"user_email" json:"user_email"`
	Sex           int32  `gorm:"column:sex" bson:"sex" json:"sex"`
	Avatar        string `gorm:"column:avatar" bson:"avatar" json:"avatar"`
	Remark        string `gorm:"column:remark" bson:"remark" json:"remark"`
	Describe      string `gorm:"column:describe" bson:"describe" json:"describe"`
	LastLoginIp   string `gorm:"column:last_login_ip" bson:"last_login_ip" json:"last_login_ip"`
	LastLoginTime int64  `gorm:"column:last_login_time" bson:"last_login_time" json:"last_login_time"`
	Role          int64  `gorm:"column:role" bson:"role" json:"role"`
	CreatedAt     int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt     int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt     int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *User) TableName() string {
	return TableNamePrefix + "user"
}

func (m *User) Cloumns() *userCloumns {
	return _userCloumns
}

func (m *User) ToProto() *bean.User {
	return &bean.User{
		Id:            int64(m.Id),
		UserName:      string(m.UserName),
		Mobile:        string(m.Mobile),
		UserNickname:  string(m.UserNickname),
		UserPinyin:    string(m.UserPinyin),
		UserPassword:  string(m.UserPassword),
		UserSalt:      string(m.UserSalt),
		UserStatus:    int32(m.UserStatus),
		UserEmail:     string(m.UserEmail),
		Sex:           int32(m.Sex),
		Avatar:        string(m.Avatar),
		Remark:        string(m.Remark),
		Describe:      string(m.Describe),
		LastLoginIp:   string(m.LastLoginIp),
		LastLoginTime: int64(m.LastLoginTime),
		Role:          int64(m.Role),
		CreatedAt:     int64(m.CreatedAt),
		UpdatedAt:     int64(m.UpdatedAt),
		DeletedAt:     int64(m.DeletedAt),
	}
}

func (m *User) FromProto(proto *bean.User) {
	m.Id = int64(proto.Id)
	m.UserName = string(proto.UserName)
	m.Mobile = string(proto.Mobile)
	m.UserNickname = string(proto.UserNickname)
	m.UserPinyin = string(proto.UserPinyin)
	m.UserPassword = string(proto.UserPassword)
	m.UserSalt = string(proto.UserSalt)
	m.UserStatus = int32(proto.UserStatus)
	m.UserEmail = string(proto.UserEmail)
	m.Sex = int32(proto.Sex)
	m.Avatar = string(proto.Avatar)
	m.Remark = string(proto.Remark)
	m.Describe = string(proto.Describe)
	m.LastLoginIp = string(proto.LastLoginIp)
	m.LastLoginTime = int64(proto.LastLoginTime)
	m.Role = int64(proto.Role)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *User) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_USER),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *User) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.User{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type userCloumns struct {
	ALL string

	Id            string
	UserName      string
	Mobile        string
	UserNickname  string
	UserPinyin    string
	UserPassword  string
	UserSalt      string
	UserStatus    string
	UserEmail     string
	Sex           string
	Avatar        string
	Remark        string
	Describe      string
	LastLoginIp   string
	LastLoginTime string
	Role          string
	CreatedAt     string
	UpdatedAt     string
	DeletedAt     string
	raw           []string
}

var _userCloumns *userCloumns = &userCloumns{
	raw: []string{
		"id", "user_name", "mobile", "user_nickname", "user_pinyin", "user_password", "user_salt", "user_status", "user_email", "sex", "avatar", "remark", "describe", "last_login_ip", "last_login_time", "role", "created_at", "updated_at", "deleted_at",
	},
	ALL:           "*",
	Id:            "id",
	UserName:      "user_name",
	Mobile:        "mobile",
	UserNickname:  "user_nickname",
	UserPinyin:    "user_pinyin",
	UserPassword:  "user_password",
	UserSalt:      "user_salt",
	UserStatus:    "user_status",
	UserEmail:     "user_email",
	Sex:           "sex",
	Avatar:        "avatar",
	Remark:        "remark",
	Describe:      "describe",
	LastLoginIp:   "last_login_ip",
	LastLoginTime: "last_login_time",
	Role:          "role",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	DeletedAt:     "deleted_at",
}

func (c *userCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *userCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// Config 表结构
// 对应的 Proto 消息类型: Config
// 数据库表名: config
type Config struct {
	Id           int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	ConfigName   string `gorm:"column:config_name" bson:"config_name" json:"config_name"`
	ConfigKey    string `gorm:"column:config_key" bson:"config_key" json:"config_key"`
	ConfigValue  string `gorm:"column:config_value" bson:"config_value" json:"config_value"`
	ConfigStatus string `gorm:"column:config_status" bson:"config_status" json:"config_status"`
	Remark       string `gorm:"column:remark" bson:"remark" json:"remark"`
	CreatedAt    int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt    int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt    int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *Config) TableName() string {
	return TableNamePrefix + "config"
}

func (m *Config) Cloumns() *configCloumns {
	return _configCloumns
}

func (m *Config) ToProto() *bean.Config {
	return &bean.Config{
		Id:           int64(m.Id),
		ConfigName:   string(m.ConfigName),
		ConfigKey:    string(m.ConfigKey),
		ConfigValue:  string(m.ConfigValue),
		ConfigStatus: string(m.ConfigStatus),
		Remark:       string(m.Remark),
		CreatedAt:    int64(m.CreatedAt),
		UpdatedAt:    int64(m.UpdatedAt),
		DeletedAt:    int64(m.DeletedAt),
	}
}

func (m *Config) FromProto(proto *bean.Config) {
	m.Id = int64(proto.Id)
	m.ConfigName = string(proto.ConfigName)
	m.ConfigKey = string(proto.ConfigKey)
	m.ConfigValue = string(proto.ConfigValue)
	m.ConfigStatus = string(proto.ConfigStatus)
	m.Remark = string(proto.Remark)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *Config) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_CONFIG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *Config) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.Config{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type configCloumns struct {
	ALL string

	Id           string
	ConfigName   string
	ConfigKey    string
	ConfigValue  string
	ConfigStatus string
	Remark       string
	CreatedAt    string
	UpdatedAt    string
	DeletedAt    string
	raw          []string
}

var _configCloumns *configCloumns = &configCloumns{
	raw: []string{
		"id", "config_name", "config_key", "config_value", "config_status", "remark", "created_at", "updated_at", "deleted_at",
	},
	ALL:          "*",
	Id:           "id",
	ConfigName:   "config_name",
	ConfigKey:    "config_key",
	ConfigValue:  "config_value",
	ConfigStatus: "config_status",
	Remark:       "remark",
	CreatedAt:    "created_at",
	UpdatedAt:    "updated_at",
	DeletedAt:    "deleted_at",
}

func (c *configCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *configCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// Space 表结构
// 对应的 Proto 消息类型: Space
// 数据库表名: space
type Space struct {
	Id          int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserId      int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceGuid   string `gorm:"column:space_guid" bson:"space_guid" json:"space_guid"`
	SpaceName   string `gorm:"column:space_name" bson:"space_name" json:"space_name"`
	SpaceStatus int32  `gorm:"column:space_status" bson:"space_status" json:"space_status"`
	Remark      string `gorm:"column:remark" bson:"remark" json:"remark"`
	Describe    string `gorm:"column:describe" bson:"describe" json:"describe"`
	Notify      int64  `gorm:"column:notify" bson:"notify" json:"notify"`
	CreatedAt   int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt   int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt   int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *Space) TableName() string {
	return TableNamePrefix + "space"
}

func (m *Space) Cloumns() *spaceCloumns {
	return _spaceCloumns
}

func (m *Space) ToProto() *bean.Space {
	return &bean.Space{
		Id:          int64(m.Id),
		UserId:      int64(m.UserId),
		SpaceGuid:   string(m.SpaceGuid),
		SpaceName:   string(m.SpaceName),
		SpaceStatus: int32(m.SpaceStatus),
		Remark:      string(m.Remark),
		Describe:    string(m.Describe),
		Notify:      int64(m.Notify),
		CreatedAt:   int64(m.CreatedAt),
		UpdatedAt:   int64(m.UpdatedAt),
		DeletedAt:   int64(m.DeletedAt),
	}
}

func (m *Space) FromProto(proto *bean.Space) {
	m.Id = int64(proto.Id)
	m.UserId = int64(proto.UserId)
	m.SpaceGuid = string(proto.SpaceGuid)
	m.SpaceName = string(proto.SpaceName)
	m.SpaceStatus = int32(proto.SpaceStatus)
	m.Remark = string(proto.Remark)
	m.Describe = string(proto.Describe)
	m.Notify = int64(proto.Notify)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *Space) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *Space) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.Space{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceCloumns struct {
	ALL string

	Id          string
	UserId      string
	SpaceGuid   string
	SpaceName   string
	SpaceStatus string
	Remark      string
	Describe    string
	Notify      string
	CreatedAt   string
	UpdatedAt   string
	DeletedAt   string
	raw         []string
}

var _spaceCloumns *spaceCloumns = &spaceCloumns{
	raw: []string{
		"id", "user_id", "space_guid", "space_name", "space_status", "remark", "describe", "notify", "created_at", "updated_at", "deleted_at",
	},
	ALL:         "*",
	Id:          "id",
	UserId:      "user_id",
	SpaceGuid:   "space_guid",
	SpaceName:   "space_name",
	SpaceStatus: "space_status",
	Remark:      "remark",
	Describe:    "describe",
	Notify:      "notify",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
	DeletedAt:   "deleted_at",
}

func (c *spaceCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceConfig 表结构
// 对应的 Proto 消息类型: SpaceConfig
// 数据库表名: space_config
type SpaceConfig struct {
	Id                           int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId                      int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkingDay                   string `gorm:"column:working_day" bson:"working_day" json:"working_day"`
	CommentDeletable             int32  `gorm:"column:comment_deletable" bson:"comment_deletable" json:"comment_deletable"`
	CommentDeletableWhenArchived int32  `gorm:"column:comment_deletable_when_archived" bson:"comment_deletable_when_archived" json:"comment_deletable_when_archived"`
	CommentShowPos               int32  `gorm:"column:comment_show_pos" bson:"comment_show_pos" json:"comment_show_pos"`
	CreatedAt                    int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt                    int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt                    int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceConfig) TableName() string {
	return TableNamePrefix + "space_config"
}

func (m *SpaceConfig) Cloumns() *spaceConfigCloumns {
	return _spaceConfigCloumns
}

func (m *SpaceConfig) ToProto() *bean.SpaceConfig {
	return &bean.SpaceConfig{
		Id:                           int64(m.Id),
		SpaceId:                      int64(m.SpaceId),
		WorkingDay:                   string(m.WorkingDay),
		CommentDeletable:             int32(m.CommentDeletable),
		CommentDeletableWhenArchived: int32(m.CommentDeletableWhenArchived),
		CommentShowPos:               int32(m.CommentShowPos),
		CreatedAt:                    int64(m.CreatedAt),
		UpdatedAt:                    int64(m.UpdatedAt),
		DeletedAt:                    int64(m.DeletedAt),
	}
}

func (m *SpaceConfig) FromProto(proto *bean.SpaceConfig) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkingDay = string(proto.WorkingDay)
	m.CommentDeletable = int32(proto.CommentDeletable)
	m.CommentDeletableWhenArchived = int32(proto.CommentDeletableWhenArchived)
	m.CommentShowPos = int32(proto.CommentShowPos)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceConfig) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_CONFIG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceConfig) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceConfig{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceConfigCloumns struct {
	ALL string

	Id                           string
	SpaceId                      string
	WorkingDay                   string
	CommentDeletable             string
	CommentDeletableWhenArchived string
	CommentShowPos               string
	CreatedAt                    string
	UpdatedAt                    string
	DeletedAt                    string
	raw                          []string
}

var _spaceConfigCloumns *spaceConfigCloumns = &spaceConfigCloumns{
	raw: []string{
		"id", "space_id", "working_day", "comment_deletable", "comment_deletable_when_archived", "comment_show_pos", "created_at", "updated_at", "deleted_at",
	},
	ALL:                          "*",
	Id:                           "id",
	SpaceId:                      "space_id",
	WorkingDay:                   "working_day",
	CommentDeletable:             "comment_deletable",
	CommentDeletableWhenArchived: "comment_deletable_when_archived",
	CommentShowPos:               "comment_show_pos",
	CreatedAt:                    "created_at",
	UpdatedAt:                    "updated_at",
	DeletedAt:                    "deleted_at",
}

func (c *spaceConfigCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceConfigCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceMember 表结构
// 对应的 Proto 消息类型: SpaceMember
// 数据库表名: space_member
type SpaceMember struct {
	Id            int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserId        int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	SpaceId       int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	RoleId        int64  `gorm:"column:role_id" bson:"role_id" json:"role_id"`
	Remark        string `gorm:"column:remark" bson:"remark" json:"remark"`
	Ranking       int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	Notify        int32  `gorm:"column:notify" bson:"notify" json:"notify"`
	CreatedAt     int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt     int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt     int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	HistoryRoleId int64  `gorm:"column:history_role_id" bson:"history_role_id" json:"history_role_id"`
}

func (m *SpaceMember) TableName() string {
	return TableNamePrefix + "space_member"
}

func (m *SpaceMember) Cloumns() *spaceMemberCloumns {
	return _spaceMemberCloumns
}

func (m *SpaceMember) ToProto() *bean.SpaceMember {
	return &bean.SpaceMember{
		Id:            int64(m.Id),
		UserId:        int64(m.UserId),
		SpaceId:       int64(m.SpaceId),
		RoleId:        int64(m.RoleId),
		Remark:        string(m.Remark),
		Ranking:       int64(m.Ranking),
		Notify:        int32(m.Notify),
		CreatedAt:     int64(m.CreatedAt),
		UpdatedAt:     int64(m.UpdatedAt),
		DeletedAt:     int64(m.DeletedAt),
		HistoryRoleId: int64(m.HistoryRoleId),
	}
}

func (m *SpaceMember) FromProto(proto *bean.SpaceMember) {
	m.Id = int64(proto.Id)
	m.UserId = int64(proto.UserId)
	m.SpaceId = int64(proto.SpaceId)
	m.RoleId = int64(proto.RoleId)
	m.Remark = string(proto.Remark)
	m.Ranking = int64(proto.Ranking)
	m.Notify = int32(proto.Notify)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.HistoryRoleId = int64(proto.HistoryRoleId)

}

func (m *SpaceMember) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_MEMBER),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceMember) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceMember{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceMemberCloumns struct {
	ALL string

	Id            string
	UserId        string
	SpaceId       string
	RoleId        string
	Remark        string
	Ranking       string
	Notify        string
	CreatedAt     string
	UpdatedAt     string
	DeletedAt     string
	HistoryRoleId string
	raw           []string
}

var _spaceMemberCloumns *spaceMemberCloumns = &spaceMemberCloumns{
	raw: []string{
		"id", "user_id", "space_id", "role_id", "remark", "ranking", "notify", "created_at", "updated_at", "deleted_at", "history_role_id",
	},
	ALL:           "*",
	Id:            "id",
	UserId:        "user_id",
	SpaceId:       "space_id",
	RoleId:        "role_id",
	Remark:        "remark",
	Ranking:       "ranking",
	Notify:        "notify",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	DeletedAt:     "deleted_at",
	HistoryRoleId: "history_role_id",
}

func (c *spaceMemberCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceMemberCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkObject 表结构
// 对应的 Proto 消息类型: SpaceWorkObject
// 数据库表名: space_work_object
type SpaceWorkObject struct {
	Id               int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId          int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	UserId           int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	WorkObjectGuid   string `gorm:"column:work_object_guid" bson:"work_object_guid" json:"work_object_guid"`
	WorkObjectName   string `gorm:"column:work_object_name" bson:"work_object_name" json:"work_object_name"`
	WorkObjectStatus int32  `gorm:"column:work_object_status" bson:"work_object_status" json:"work_object_status"`
	Remark           string `gorm:"column:remark" bson:"remark" json:"remark"`
	Describe         string `gorm:"column:describe" bson:"describe" json:"describe"`
	Ranking          int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	CreatedAt        int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt        int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt        int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceWorkObject) TableName() string {
	return TableNamePrefix + "space_work_object"
}

func (m *SpaceWorkObject) Cloumns() *spaceWorkObjectCloumns {
	return _spaceWorkObjectCloumns
}

func (m *SpaceWorkObject) ToProto() *bean.SpaceWorkObject {
	return &bean.SpaceWorkObject{
		Id:               int64(m.Id),
		SpaceId:          int64(m.SpaceId),
		UserId:           int64(m.UserId),
		WorkObjectGuid:   string(m.WorkObjectGuid),
		WorkObjectName:   string(m.WorkObjectName),
		WorkObjectStatus: int32(m.WorkObjectStatus),
		Remark:           string(m.Remark),
		Describe:         string(m.Describe),
		Ranking:          int64(m.Ranking),
		CreatedAt:        int64(m.CreatedAt),
		UpdatedAt:        int64(m.UpdatedAt),
		DeletedAt:        int64(m.DeletedAt),
	}
}

func (m *SpaceWorkObject) FromProto(proto *bean.SpaceWorkObject) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.UserId = int64(proto.UserId)
	m.WorkObjectGuid = string(proto.WorkObjectGuid)
	m.WorkObjectName = string(proto.WorkObjectName)
	m.WorkObjectStatus = int32(proto.WorkObjectStatus)
	m.Remark = string(proto.Remark)
	m.Describe = string(proto.Describe)
	m.Ranking = int64(proto.Ranking)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceWorkObject) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_OBJECT),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkObject) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkObject{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkObjectCloumns struct {
	ALL string

	Id               string
	SpaceId          string
	UserId           string
	WorkObjectGuid   string
	WorkObjectName   string
	WorkObjectStatus string
	Remark           string
	Describe         string
	Ranking          string
	CreatedAt        string
	UpdatedAt        string
	DeletedAt        string
	raw              []string
}

var _spaceWorkObjectCloumns *spaceWorkObjectCloumns = &spaceWorkObjectCloumns{
	raw: []string{
		"id", "space_id", "user_id", "work_object_guid", "work_object_name", "work_object_status", "remark", "describe", "ranking", "created_at", "updated_at", "deleted_at",
	},
	ALL:              "*",
	Id:               "id",
	SpaceId:          "space_id",
	UserId:           "user_id",
	WorkObjectGuid:   "work_object_guid",
	WorkObjectName:   "work_object_name",
	WorkObjectStatus: "work_object_status",
	Remark:           "remark",
	Describe:         "describe",
	Ranking:          "ranking",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	DeletedAt:        "deleted_at",
}

func (c *spaceWorkObjectCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkObjectCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkItemV2 表结构
// 对应的 Proto 消息类型: SpaceWorkItemV2
// 数据库表名: space_work_item_v2
type SpaceWorkItemV2 struct {
	Id                  int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Pid                 int64  `gorm:"column:pid" bson:"pid" json:"pid"`
	SpaceId             int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	UserId              int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	WorkItemType        int32  `gorm:"column:work_item_type" bson:"work_item_type" json:"work_item_type"`
	WorkObjectId        int64  `gorm:"column:work_object_id" bson:"work_object_id" json:"work_object_id"`
	WorkItemGuid        string `gorm:"column:work_item_guid" bson:"work_item_guid" json:"work_item_guid"`
	WorkItemName        string `gorm:"column:work_item_name" bson:"work_item_name" json:"work_item_name"`
	CreatedAt           int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt           int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt           int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	Doc                 string `gorm:"column:doc" bson:"doc" json:"doc"`
	IsRestart           int32  `gorm:"column:is_restart" bson:"is_restart" json:"is_restart"`
	RestartAt           int64  `gorm:"column:restart_at" bson:"restart_at" json:"restart_at"`
	IconFlags           uint32 `gorm:"column:icon_flags" bson:"icon_flags" json:"icon_flags"`
	RestartUserId       int64  `gorm:"column:restart_user_id" bson:"restart_user_id" json:"restart_user_id"`
	CommentNum          int32  `gorm:"column:comment_num" bson:"comment_num" json:"comment_num"`
	ResumeAt            int64  `gorm:"column:resume_at" bson:"resume_at" json:"resume_at"`
	VersionId           int64  `gorm:"column:version_id" bson:"version_id" json:"version_id"`
	WorkItemTypeId      int64  `gorm:"column:work_item_type_id" bson:"work_item_type_id" json:"work_item_type_id"`
	WorkItemTypeKey     string `gorm:"column:work_item_type_key" bson:"work_item_type_key" json:"work_item_type_key"`
	FlowTemplateId      int64  `gorm:"column:flow_template_id" bson:"flow_template_id" json:"flow_template_id"`
	FlowTemplateVersion int64  `gorm:"column:flow_template_version" bson:"flow_template_version" json:"flow_template_version"`
	FlowId              int64  `gorm:"column:flow_id" bson:"flow_id" json:"flow_id"`
	FlowKey             string `gorm:"column:flow_key" bson:"flow_key" json:"flow_key"`
	FlowMode            string `gorm:"column:flow_mode" bson:"flow_mode" json:"flow_mode"`
	FlowModeVersion     string `gorm:"column:flow_mode_version" bson:"flow_mode_version" json:"flow_mode_version"`
	FlowModeCode        string `gorm:"column:flow_mode_code" bson:"flow_mode_code" json:"flow_mode_code"`
	WorkItemStatus      string `gorm:"column:work_item_status" bson:"work_item_status" json:"work_item_status"`
	WorkItemStatusKey   string `gorm:"column:work_item_status_key" bson:"work_item_status_key" json:"work_item_status_key"`
	WorkItemStatusId    int64  `gorm:"column:work_item_status_id" bson:"work_item_status_id" json:"work_item_status_id"`
	LastStatusAt        int64  `gorm:"column:last_status_at" bson:"last_status_at" json:"last_status_at"`
	LastStatus          string `gorm:"column:last_status" bson:"last_status" json:"last_status"`
	LastStatusKey       string `gorm:"column:last_status_key" bson:"last_status_key" json:"last_status_key"`
	LastStatusId        int64  `gorm:"column:last_status_id" bson:"last_status_id" json:"last_status_id"`
	ChildNum            int32  `gorm:"column:child_num" bson:"child_num" json:"child_num"`
	WorkItemFlowId      int64  `gorm:"column:work_item_flow_id" bson:"work_item_flow_id" json:"work_item_flow_id"`
	WorkItemFlowKey     string `gorm:"column:work_item_flow_key" bson:"work_item_flow_key" json:"work_item_flow_key"`
	Reason              string `gorm:"column:reason" bson:"reason" json:"reason"`
	CountAt             int64  `gorm:"column:count_at" bson:"count_at" json:"count_at"`
}

func (m *SpaceWorkItemV2) TableName() string {
	return TableNamePrefix + "space_work_item_v2"
}

func (m *SpaceWorkItemV2) Cloumns() *spaceWorkItemV2Cloumns {
	return _spaceWorkItemV2Cloumns
}

func (m *SpaceWorkItemV2) ToProto() *bean.SpaceWorkItemV2 {
	return &bean.SpaceWorkItemV2{
		Id:                  int64(m.Id),
		Pid:                 int64(m.Pid),
		SpaceId:             int64(m.SpaceId),
		UserId:              int64(m.UserId),
		WorkItemType:        int32(m.WorkItemType),
		WorkObjectId:        int64(m.WorkObjectId),
		WorkItemGuid:        string(m.WorkItemGuid),
		WorkItemName:        string(m.WorkItemName),
		CreatedAt:           int64(m.CreatedAt),
		UpdatedAt:           int64(m.UpdatedAt),
		DeletedAt:           int64(m.DeletedAt),
		Doc:                 string(m.Doc),
		IsRestart:           int32(m.IsRestart),
		RestartAt:           int64(m.RestartAt),
		IconFlags:           uint32(m.IconFlags),
		RestartUserId:       int64(m.RestartUserId),
		CommentNum:          int32(m.CommentNum),
		ResumeAt:            int64(m.ResumeAt),
		VersionId:           int64(m.VersionId),
		WorkItemTypeId:      int64(m.WorkItemTypeId),
		WorkItemTypeKey:     string(m.WorkItemTypeKey),
		FlowTemplateId:      int64(m.FlowTemplateId),
		FlowTemplateVersion: int64(m.FlowTemplateVersion),
		FlowId:              int64(m.FlowId),
		FlowKey:             string(m.FlowKey),
		FlowMode:            string(m.FlowMode),
		FlowModeVersion:     string(m.FlowModeVersion),
		FlowModeCode:        string(m.FlowModeCode),
		WorkItemStatus:      string(m.WorkItemStatus),
		WorkItemStatusKey:   string(m.WorkItemStatusKey),
		WorkItemStatusId:    int64(m.WorkItemStatusId),
		LastStatusAt:        int64(m.LastStatusAt),
		LastStatus:          string(m.LastStatus),
		LastStatusKey:       string(m.LastStatusKey),
		LastStatusId:        int64(m.LastStatusId),
		ChildNum:            int32(m.ChildNum),
		WorkItemFlowId:      int64(m.WorkItemFlowId),
		WorkItemFlowKey:     string(m.WorkItemFlowKey),
		Reason:              string(m.Reason),
		CountAt:             int64(m.CountAt),
	}
}

func (m *SpaceWorkItemV2) FromProto(proto *bean.SpaceWorkItemV2) {
	m.Id = int64(proto.Id)
	m.Pid = int64(proto.Pid)
	m.SpaceId = int64(proto.SpaceId)
	m.UserId = int64(proto.UserId)
	m.WorkItemType = int32(proto.WorkItemType)
	m.WorkObjectId = int64(proto.WorkObjectId)
	m.WorkItemGuid = string(proto.WorkItemGuid)
	m.WorkItemName = string(proto.WorkItemName)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.Doc = string(proto.Doc)
	m.IsRestart = int32(proto.IsRestart)
	m.RestartAt = int64(proto.RestartAt)
	m.IconFlags = uint32(proto.IconFlags)
	m.RestartUserId = int64(proto.RestartUserId)
	m.CommentNum = int32(proto.CommentNum)
	m.ResumeAt = int64(proto.ResumeAt)
	m.VersionId = int64(proto.VersionId)
	m.WorkItemTypeId = int64(proto.WorkItemTypeId)
	m.WorkItemTypeKey = string(proto.WorkItemTypeKey)
	m.FlowTemplateId = int64(proto.FlowTemplateId)
	m.FlowTemplateVersion = int64(proto.FlowTemplateVersion)
	m.FlowId = int64(proto.FlowId)
	m.FlowKey = string(proto.FlowKey)
	m.FlowMode = string(proto.FlowMode)
	m.FlowModeVersion = string(proto.FlowModeVersion)
	m.FlowModeCode = string(proto.FlowModeCode)
	m.WorkItemStatus = string(proto.WorkItemStatus)
	m.WorkItemStatusKey = string(proto.WorkItemStatusKey)
	m.WorkItemStatusId = int64(proto.WorkItemStatusId)
	m.LastStatusAt = int64(proto.LastStatusAt)
	m.LastStatus = string(proto.LastStatus)
	m.LastStatusKey = string(proto.LastStatusKey)
	m.LastStatusId = int64(proto.LastStatusId)
	m.ChildNum = int32(proto.ChildNum)
	m.WorkItemFlowId = int64(proto.WorkItemFlowId)
	m.WorkItemFlowKey = string(proto.WorkItemFlowKey)
	m.Reason = string(proto.Reason)
	m.CountAt = int64(proto.CountAt)

}

func (m *SpaceWorkItemV2) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_ITEM_V_2),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkItemV2) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkItemV2{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkItemV2Cloumns struct {
	ALL string

	Id                  string
	Pid                 string
	SpaceId             string
	UserId              string
	WorkItemType        string
	WorkObjectId        string
	WorkItemGuid        string
	WorkItemName        string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	Doc                 string
	IsRestart           string
	RestartAt           string
	IconFlags           string
	RestartUserId       string
	CommentNum          string
	ResumeAt            string
	VersionId           string
	WorkItemTypeId      string
	WorkItemTypeKey     string
	FlowTemplateId      string
	FlowTemplateVersion string
	FlowId              string
	FlowKey             string
	FlowMode            string
	FlowModeVersion     string
	FlowModeCode        string
	WorkItemStatus      string
	WorkItemStatusKey   string
	WorkItemStatusId    string
	LastStatusAt        string
	LastStatus          string
	LastStatusKey       string
	LastStatusId        string
	ChildNum            string
	WorkItemFlowId      string
	WorkItemFlowKey     string
	Reason              string
	CountAt             string
	raw                 []string
}

var _spaceWorkItemV2Cloumns *spaceWorkItemV2Cloumns = &spaceWorkItemV2Cloumns{
	raw: []string{
		"id", "pid", "space_id", "user_id", "work_item_type", "work_object_id", "work_item_guid", "work_item_name", "created_at", "updated_at", "deleted_at", "doc", "is_restart", "restart_at", "icon_flags", "restart_user_id", "comment_num", "resume_at", "version_id", "work_item_type_id", "work_item_type_key", "flow_template_id", "flow_template_version", "flow_id", "flow_key", "flow_mode", "flow_mode_version", "flow_mode_code", "work_item_status", "work_item_status_key", "work_item_status_id", "last_status_at", "last_status", "last_status_key", "last_status_id", "child_num", "work_item_flow_id", "work_item_flow_key", "reason", "count_at",
	},
	ALL:                 "*",
	Id:                  "id",
	Pid:                 "pid",
	SpaceId:             "space_id",
	UserId:              "user_id",
	WorkItemType:        "work_item_type",
	WorkObjectId:        "work_object_id",
	WorkItemGuid:        "work_item_guid",
	WorkItemName:        "work_item_name",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
	Doc:                 "doc",
	IsRestart:           "is_restart",
	RestartAt:           "restart_at",
	IconFlags:           "icon_flags",
	RestartUserId:       "restart_user_id",
	CommentNum:          "comment_num",
	ResumeAt:            "resume_at",
	VersionId:           "version_id",
	WorkItemTypeId:      "work_item_type_id",
	WorkItemTypeKey:     "work_item_type_key",
	FlowTemplateId:      "flow_template_id",
	FlowTemplateVersion: "flow_template_version",
	FlowId:              "flow_id",
	FlowKey:             "flow_key",
	FlowMode:            "flow_mode",
	FlowModeVersion:     "flow_mode_version",
	FlowModeCode:        "flow_mode_code",
	WorkItemStatus:      "work_item_status",
	WorkItemStatusKey:   "work_item_status_key",
	WorkItemStatusId:    "work_item_status_id",
	LastStatusAt:        "last_status_at",
	LastStatus:          "last_status",
	LastStatusKey:       "last_status_key",
	LastStatusId:        "last_status_id",
	ChildNum:            "child_num",
	WorkItemFlowId:      "work_item_flow_id",
	WorkItemFlowKey:     "work_item_flow_key",
	Reason:              "reason",
	CountAt:             "count_at",
}

func (c *spaceWorkItemV2Cloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkItemV2Cloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkItemDocV2 表结构
// 对应的 Proto 消息类型: SpaceWorkItemDocV2
// 数据库表名: space_work_item_doc_v2
type SpaceWorkItemDocV2 struct {
	PlanStartAt    int64  `gorm:"column:plan_start_at" bson:"plan_start_at" json:"plan_start_at"`
	PlanCompleteAt int64  `gorm:"column:plan_complete_at" bson:"plan_complete_at" json:"plan_complete_at"`
	ProcessRate    int32  `gorm:"column:process_rate" bson:"process_rate" json:"process_rate"`
	Remark         string `gorm:"column:remark" bson:"remark" json:"remark"`
	Describe       string `gorm:"column:describe" bson:"describe" json:"describe"`
	Priority       string `gorm:"column:priority" bson:"priority" json:"priority"`
	Tags           string `gorm:"column:tags" bson:"tags" json:"tags"`
	Directors      string `gorm:"column:directors" bson:"directors" json:"directors"`
	Followers      string `gorm:"column:followers" bson:"followers" json:"followers"`
	Participators  string `gorm:"column:participators" bson:"participators" json:"participators"`
	NodeDirectors  string `gorm:"column:node_directors" bson:"node_directors" json:"node_directors"`
}

func (m *SpaceWorkItemDocV2) TableName() string {
	return TableNamePrefix + "space_work_item_doc_v2"
}

func (m *SpaceWorkItemDocV2) Cloumns() *spaceWorkItemDocV2Cloumns {
	return _spaceWorkItemDocV2Cloumns
}

func (m *SpaceWorkItemDocV2) ToProto() *bean.SpaceWorkItemDocV2 {
	return &bean.SpaceWorkItemDocV2{
		PlanStartAt:    int64(m.PlanStartAt),
		PlanCompleteAt: int64(m.PlanCompleteAt),
		ProcessRate:    int32(m.ProcessRate),
		Remark:         string(m.Remark),
		Describe:       string(m.Describe),
		Priority:       string(m.Priority),
		Tags:           string(m.Tags),
		Directors:      string(m.Directors),
		Followers:      string(m.Followers),
		Participators:  string(m.Participators),
		NodeDirectors:  string(m.NodeDirectors),
	}
}

func (m *SpaceWorkItemDocV2) FromProto(proto *bean.SpaceWorkItemDocV2) {
	m.PlanStartAt = int64(proto.PlanStartAt)
	m.PlanCompleteAt = int64(proto.PlanCompleteAt)
	m.ProcessRate = int32(proto.ProcessRate)
	m.Remark = string(proto.Remark)
	m.Describe = string(proto.Describe)
	m.Priority = string(proto.Priority)
	m.Tags = string(proto.Tags)
	m.Directors = string(proto.Directors)
	m.Followers = string(proto.Followers)
	m.Participators = string(proto.Participators)
	m.NodeDirectors = string(proto.NodeDirectors)

}

func (m *SpaceWorkItemDocV2) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_ITEM_DOC_V_2),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkItemDocV2) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkItemDocV2{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkItemDocV2Cloumns struct {
	ALL string

	PlanStartAt    string
	PlanCompleteAt string
	ProcessRate    string
	Remark         string
	Describe       string
	Priority       string
	Tags           string
	Directors      string
	Followers      string
	Participators  string
	NodeDirectors  string
	raw            []string
}

var _spaceWorkItemDocV2Cloumns *spaceWorkItemDocV2Cloumns = &spaceWorkItemDocV2Cloumns{
	raw: []string{
		"plan_start_at", "plan_complete_at", "process_rate", "remark", "describe", "priority", "tags", "directors", "followers", "participators", "node_directors",
	},
	ALL:            "*",
	PlanStartAt:    "plan_start_at",
	PlanCompleteAt: "plan_complete_at",
	ProcessRate:    "process_rate",
	Remark:         "remark",
	Describe:       "describe",
	Priority:       "priority",
	Tags:           "tags",
	Directors:      "directors",
	Followers:      "followers",
	Participators:  "participators",
	NodeDirectors:  "node_directors",
}

func (c *spaceWorkItemDocV2Cloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkItemDocV2Cloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceTag 表结构
// 对应的 Proto 消息类型: SpaceTag
// 数据库表名: space_tag
type SpaceTag struct {
	Id        int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId   int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	TagGuid   string `gorm:"column:tag_guid" bson:"tag_guid" json:"tag_guid"`
	TagName   string `gorm:"column:tag_name" bson:"tag_name" json:"tag_name"`
	TagStatus int32  `gorm:"column:tag_status" bson:"tag_status" json:"tag_status"`
	CreatedAt int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceTag) TableName() string {
	return TableNamePrefix + "space_tag"
}

func (m *SpaceTag) Cloumns() *spaceTagCloumns {
	return _spaceTagCloumns
}

func (m *SpaceTag) ToProto() *bean.SpaceTag {
	return &bean.SpaceTag{
		Id:        int64(m.Id),
		SpaceId:   int64(m.SpaceId),
		TagGuid:   string(m.TagGuid),
		TagName:   string(m.TagName),
		TagStatus: int32(m.TagStatus),
		CreatedAt: int64(m.CreatedAt),
		UpdatedAt: int64(m.UpdatedAt),
		DeletedAt: int64(m.DeletedAt),
	}
}

func (m *SpaceTag) FromProto(proto *bean.SpaceTag) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.TagGuid = string(proto.TagGuid)
	m.TagName = string(proto.TagName)
	m.TagStatus = int32(proto.TagStatus)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceTag) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_TAG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceTag) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceTag{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceTagCloumns struct {
	ALL string

	Id        string
	SpaceId   string
	TagGuid   string
	TagName   string
	TagStatus string
	CreatedAt string
	UpdatedAt string
	DeletedAt string
	raw       []string
}

var _spaceTagCloumns *spaceTagCloumns = &spaceTagCloumns{
	raw: []string{
		"id", "space_id", "tag_guid", "tag_name", "tag_status", "created_at", "updated_at", "deleted_at",
	},
	ALL:       "*",
	Id:        "id",
	SpaceId:   "space_id",
	TagGuid:   "tag_guid",
	TagName:   "tag_name",
	TagStatus: "tag_status",
	CreatedAt: "created_at",
	UpdatedAt: "updated_at",
	DeletedAt: "deleted_at",
}

func (c *spaceTagCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceTagCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// FileInfo 表结构
// 对应的 Proto 消息类型: FileInfo
// 数据库表名: file_info
type FileInfo struct {
	Id           int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Hash         string `gorm:"column:hash" bson:"hash" json:"hash"`
	Name         string `gorm:"column:name" bson:"name" json:"name"`
	Typ          int32  `gorm:"column:typ" bson:"typ" json:"typ"`
	Size         int64  `gorm:"column:size" bson:"size" json:"size"`
	Uri          string `gorm:"column:uri" bson:"uri" json:"uri"`
	Pwd          string `gorm:"column:pwd" bson:"pwd" json:"pwd"`
	Cover        string `gorm:"column:cover" bson:"cover" json:"cover"`
	Status       int32  `gorm:"column:status" bson:"status" json:"status"`
	Owner        int64  `gorm:"column:owner" bson:"owner" json:"owner"`
	Meta         string `gorm:"column:meta" bson:"meta" json:"meta"`
	CreatedAt    int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt    int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt    int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	UploadTyp    int32  `gorm:"column:upload_typ" bson:"upload_typ" json:"upload_typ"`
	UploadDomain string `gorm:"column:upload_domain" bson:"upload_domain" json:"upload_domain"`
	UploadMd5    string `gorm:"column:upload_md5" bson:"upload_md5" json:"upload_md5"`
	UploadPath   string `gorm:"column:upload_path" bson:"upload_path" json:"upload_path"`
}

func (m *FileInfo) TableName() string {
	return TableNamePrefix + "file_info"
}

func (m *FileInfo) Cloumns() *fileInfoCloumns {
	return _fileInfoCloumns
}

func (m *FileInfo) ToProto() *bean.FileInfo {
	return &bean.FileInfo{
		Id:           int64(m.Id),
		Hash:         string(m.Hash),
		Name:         string(m.Name),
		Typ:          int32(m.Typ),
		Size:         int64(m.Size),
		Uri:          string(m.Uri),
		Pwd:          string(m.Pwd),
		Cover:        string(m.Cover),
		Status:       int32(m.Status),
		Owner:        int64(m.Owner),
		Meta:         string(m.Meta),
		CreatedAt:    int64(m.CreatedAt),
		UpdatedAt:    int64(m.UpdatedAt),
		DeletedAt:    int64(m.DeletedAt),
		UploadTyp:    int32(m.UploadTyp),
		UploadDomain: string(m.UploadDomain),
		UploadMd5:    string(m.UploadMd5),
		UploadPath:   string(m.UploadPath),
	}
}

func (m *FileInfo) FromProto(proto *bean.FileInfo) {
	m.Id = int64(proto.Id)
	m.Hash = string(proto.Hash)
	m.Name = string(proto.Name)
	m.Typ = int32(proto.Typ)
	m.Size = int64(proto.Size)
	m.Uri = string(proto.Uri)
	m.Pwd = string(proto.Pwd)
	m.Cover = string(proto.Cover)
	m.Status = int32(proto.Status)
	m.Owner = int64(proto.Owner)
	m.Meta = string(proto.Meta)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.UploadTyp = int32(proto.UploadTyp)
	m.UploadDomain = string(proto.UploadDomain)
	m.UploadMd5 = string(proto.UploadMd5)
	m.UploadPath = string(proto.UploadPath)

}

func (m *FileInfo) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_FILE_INFO),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *FileInfo) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.FileInfo{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type fileInfoCloumns struct {
	ALL string

	Id           string
	Hash         string
	Name         string
	Typ          string
	Size         string
	Uri          string
	Pwd          string
	Cover        string
	Status       string
	Owner        string
	Meta         string
	CreatedAt    string
	UpdatedAt    string
	DeletedAt    string
	UploadTyp    string
	UploadDomain string
	UploadMd5    string
	UploadPath   string
	raw          []string
}

var _fileInfoCloumns *fileInfoCloumns = &fileInfoCloumns{
	raw: []string{
		"id", "hash", "name", "typ", "size", "uri", "pwd", "cover", "status", "owner", "meta", "created_at", "updated_at", "deleted_at", "upload_typ", "upload_domain", "upload_md5", "upload_path",
	},
	ALL:          "*",
	Id:           "id",
	Hash:         "hash",
	Name:         "name",
	Typ:          "typ",
	Size:         "size",
	Uri:          "uri",
	Pwd:          "pwd",
	Cover:        "cover",
	Status:       "status",
	Owner:        "owner",
	Meta:         "meta",
	CreatedAt:    "created_at",
	UpdatedAt:    "updated_at",
	DeletedAt:    "deleted_at",
	UploadTyp:    "upload_typ",
	UploadDomain: "upload_domain",
	UploadMd5:    "upload_md5",
	UploadPath:   "upload_path",
}

func (c *fileInfoCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *fileInfoCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceFileInfo 表结构
// 对应的 Proto 消息类型: SpaceFileInfo
// 数据库表名: space_file_info
type SpaceFileInfo struct {
	Id         int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId    int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	FileInfoId int64  `gorm:"column:file_info_id" bson:"file_info_id" json:"file_info_id"`
	FileName   string `gorm:"column:file_name" bson:"file_name" json:"file_name"`
	FileUri    string `gorm:"column:file_uri" bson:"file_uri" json:"file_uri"`
	FileSize   int64  `gorm:"column:file_size" bson:"file_size" json:"file_size"`
	Status     int32  `gorm:"column:status" bson:"status" json:"status"`
	SourceId   int64  `gorm:"column:source_id" bson:"source_id" json:"source_id"`
	SourceType int32  `gorm:"column:source_type" bson:"source_type" json:"source_type"`
	CreatedAt  int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt  int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt  int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceFileInfo) TableName() string {
	return TableNamePrefix + "space_file_info"
}

func (m *SpaceFileInfo) Cloumns() *spaceFileInfoCloumns {
	return _spaceFileInfoCloumns
}

func (m *SpaceFileInfo) ToProto() *bean.SpaceFileInfo {
	return &bean.SpaceFileInfo{
		Id:         int64(m.Id),
		SpaceId:    int64(m.SpaceId),
		FileInfoId: int64(m.FileInfoId),
		FileName:   string(m.FileName),
		FileUri:    string(m.FileUri),
		FileSize:   int64(m.FileSize),
		Status:     int32(m.Status),
		SourceId:   int64(m.SourceId),
		SourceType: int32(m.SourceType),
		CreatedAt:  int64(m.CreatedAt),
		UpdatedAt:  int64(m.UpdatedAt),
		DeletedAt:  int64(m.DeletedAt),
	}
}

func (m *SpaceFileInfo) FromProto(proto *bean.SpaceFileInfo) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.FileInfoId = int64(proto.FileInfoId)
	m.FileName = string(proto.FileName)
	m.FileUri = string(proto.FileUri)
	m.FileSize = int64(proto.FileSize)
	m.Status = int32(proto.Status)
	m.SourceId = int64(proto.SourceId)
	m.SourceType = int32(proto.SourceType)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceFileInfo) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_FILE_INFO),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceFileInfo) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceFileInfo{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceFileInfoCloumns struct {
	ALL string

	Id         string
	SpaceId    string
	FileInfoId string
	FileName   string
	FileUri    string
	FileSize   string
	Status     string
	SourceId   string
	SourceType string
	CreatedAt  string
	UpdatedAt  string
	DeletedAt  string
	raw        []string
}

var _spaceFileInfoCloumns *spaceFileInfoCloumns = &spaceFileInfoCloumns{
	raw: []string{
		"id", "space_id", "file_info_id", "file_name", "file_uri", "file_size", "status", "source_id", "source_type", "created_at", "updated_at", "deleted_at",
	},
	ALL:        "*",
	Id:         "id",
	SpaceId:    "space_id",
	FileInfoId: "file_info_id",
	FileName:   "file_name",
	FileUri:    "file_uri",
	FileSize:   "file_size",
	Status:     "status",
	SourceId:   "source_id",
	SourceType: "source_type",
	CreatedAt:  "created_at",
	UpdatedAt:  "updated_at",
	DeletedAt:  "deleted_at",
}

func (c *spaceFileInfoCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceFileInfoCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// UserLoginLog 表结构
// 对应的 Proto 消息类型: UserLoginLog
// 数据库表名: user_login_log
type UserLoginLog struct {
	Id                int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	LoginUserId       int64  `gorm:"column:login_user_id" bson:"login_user_id" json:"login_user_id"`
	LoginUserName     string `gorm:"column:login_user_name" bson:"login_user_name" json:"login_user_name"`
	LoginUserNickname string `gorm:"column:login_user_nickname" bson:"login_user_nickname" json:"login_user_nickname"`
	Ipaddr            string `gorm:"column:ipaddr" bson:"ipaddr" json:"ipaddr"`
	LoginLocation     string `gorm:"column:login_location" bson:"login_location" json:"login_location"`
	Browser           string `gorm:"column:browser" bson:"browser" json:"browser"`
	Os                string `gorm:"column:os" bson:"os" json:"os"`
	Status            int32  `gorm:"column:status" bson:"status" json:"status"`
	Msg               string `gorm:"column:msg" bson:"msg" json:"msg"`
	LoginAt           int64  `gorm:"column:login_at" bson:"login_at" json:"login_at"`
	CreatedAt         int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt         int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt         int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *UserLoginLog) TableName() string {
	return TableNamePrefix + "user_login_log"
}

func (m *UserLoginLog) Cloumns() *userLoginLogCloumns {
	return _userLoginLogCloumns
}

func (m *UserLoginLog) ToProto() *bean.UserLoginLog {
	return &bean.UserLoginLog{
		Id:                int64(m.Id),
		LoginUserId:       int64(m.LoginUserId),
		LoginUserName:     string(m.LoginUserName),
		LoginUserNickname: string(m.LoginUserNickname),
		Ipaddr:            string(m.Ipaddr),
		LoginLocation:     string(m.LoginLocation),
		Browser:           string(m.Browser),
		Os:                string(m.Os),
		Status:            int32(m.Status),
		Msg:               string(m.Msg),
		LoginAt:           int64(m.LoginAt),
		CreatedAt:         int64(m.CreatedAt),
		UpdatedAt:         int64(m.UpdatedAt),
		DeletedAt:         int64(m.DeletedAt),
	}
}

func (m *UserLoginLog) FromProto(proto *bean.UserLoginLog) {
	m.Id = int64(proto.Id)
	m.LoginUserId = int64(proto.LoginUserId)
	m.LoginUserName = string(proto.LoginUserName)
	m.LoginUserNickname = string(proto.LoginUserNickname)
	m.Ipaddr = string(proto.Ipaddr)
	m.LoginLocation = string(proto.LoginLocation)
	m.Browser = string(proto.Browser)
	m.Os = string(proto.Os)
	m.Status = int32(proto.Status)
	m.Msg = string(proto.Msg)
	m.LoginAt = int64(proto.LoginAt)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *UserLoginLog) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_USER_LOGIN_LOG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *UserLoginLog) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.UserLoginLog{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type userLoginLogCloumns struct {
	ALL string

	Id                string
	LoginUserId       string
	LoginUserName     string
	LoginUserNickname string
	Ipaddr            string
	LoginLocation     string
	Browser           string
	Os                string
	Status            string
	Msg               string
	LoginAt           string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
	raw               []string
}

var _userLoginLogCloumns *userLoginLogCloumns = &userLoginLogCloumns{
	raw: []string{
		"id", "login_user_id", "login_user_name", "login_user_nickname", "ipaddr", "login_location", "browser", "os", "status", "msg", "login_at", "created_at", "updated_at", "deleted_at",
	},
	ALL:               "*",
	Id:                "id",
	LoginUserId:       "login_user_id",
	LoginUserName:     "login_user_name",
	LoginUserNickname: "login_user_nickname",
	Ipaddr:            "ipaddr",
	LoginLocation:     "login_location",
	Browser:           "browser",
	Os:                "os",
	Status:            "status",
	Msg:               "msg",
	LoginAt:           "login_at",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
	DeletedAt:         "deleted_at",
}

func (c *userLoginLogCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *userLoginLogCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// OperLog 表结构
// 对应的 Proto 消息类型: OperLog
// 数据库表名: oper_log
type OperLog struct {
	Id            int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	Title         string `gorm:"column:title" bson:"title" json:"title"`
	BusinessType  int32  `gorm:"column:business_type" bson:"business_type" json:"business_type"`
	Method        string `gorm:"column:method" bson:"method" json:"method"`
	RequestMethod string `gorm:"column:request_method" bson:"request_method" json:"request_method"`
	ModuleType    int32  `gorm:"column:module_type" bson:"module_type" json:"module_type"`
	ModuleId      int64  `gorm:"column:module_id" bson:"module_id" json:"module_id"`
	OperatorType  int32  `gorm:"column:operator_type" bson:"operator_type" json:"operator_type"`
	OperId        int64  `gorm:"column:oper_id" bson:"oper_id" json:"oper_id"`
	OperName      string `gorm:"column:oper_name" bson:"oper_name" json:"oper_name"`
	OperNickname  string `gorm:"column:oper_nickname" bson:"oper_nickname" json:"oper_nickname"`
	OperUrl       string `gorm:"column:oper_url" bson:"oper_url" json:"oper_url"`
	OperIp        string `gorm:"column:oper_ip" bson:"oper_ip" json:"oper_ip"`
	OperLocation  string `gorm:"column:oper_location" bson:"oper_location" json:"oper_location"`
	OperParam     string `gorm:"column:oper_param" bson:"oper_param" json:"oper_param"`
	OperMsg       string `gorm:"column:oper_msg" bson:"oper_msg" json:"oper_msg"`
	OperTimeAt    int64  `gorm:"column:oper_time_at" bson:"oper_time_at" json:"oper_time_at"`
	CreatedAt     int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt     int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt     int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	SpaceId       int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	ShowType      int32  `gorm:"column:show_type" bson:"show_type" json:"show_type"`
	SpaceName     string `gorm:"column:space_name" bson:"space_name" json:"space_name"`
	ModuleFlag    int64  `gorm:"column:module_flag" bson:"module_flag" json:"module_flag"`
}

func (m *OperLog) TableName() string {
	return TableNamePrefix + "oper_log"
}

func (m *OperLog) Cloumns() *operLogCloumns {
	return _operLogCloumns
}

func (m *OperLog) ToProto() *bean.OperLog {
	return &bean.OperLog{
		Id:            int64(m.Id),
		Title:         string(m.Title),
		BusinessType:  int32(m.BusinessType),
		Method:        string(m.Method),
		RequestMethod: string(m.RequestMethod),
		ModuleType:    int32(m.ModuleType),
		ModuleId:      int64(m.ModuleId),
		OperatorType:  int32(m.OperatorType),
		OperId:        int64(m.OperId),
		OperName:      string(m.OperName),
		OperNickname:  string(m.OperNickname),
		OperUrl:       string(m.OperUrl),
		OperIp:        string(m.OperIp),
		OperLocation:  string(m.OperLocation),
		OperParam:     string(m.OperParam),
		OperMsg:       string(m.OperMsg),
		OperTimeAt:    int64(m.OperTimeAt),
		CreatedAt:     int64(m.CreatedAt),
		UpdatedAt:     int64(m.UpdatedAt),
		DeletedAt:     int64(m.DeletedAt),
		SpaceId:       int64(m.SpaceId),
		ShowType:      int32(m.ShowType),
		SpaceName:     string(m.SpaceName),
		ModuleFlag:    int64(m.ModuleFlag),
	}
}

func (m *OperLog) FromProto(proto *bean.OperLog) {
	m.Id = int64(proto.Id)
	m.Title = string(proto.Title)
	m.BusinessType = int32(proto.BusinessType)
	m.Method = string(proto.Method)
	m.RequestMethod = string(proto.RequestMethod)
	m.ModuleType = int32(proto.ModuleType)
	m.ModuleId = int64(proto.ModuleId)
	m.OperatorType = int32(proto.OperatorType)
	m.OperId = int64(proto.OperId)
	m.OperName = string(proto.OperName)
	m.OperNickname = string(proto.OperNickname)
	m.OperUrl = string(proto.OperUrl)
	m.OperIp = string(proto.OperIp)
	m.OperLocation = string(proto.OperLocation)
	m.OperParam = string(proto.OperParam)
	m.OperMsg = string(proto.OperMsg)
	m.OperTimeAt = int64(proto.OperTimeAt)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.SpaceId = int64(proto.SpaceId)
	m.ShowType = int32(proto.ShowType)
	m.SpaceName = string(proto.SpaceName)
	m.ModuleFlag = int64(proto.ModuleFlag)

}

func (m *OperLog) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_OPER_LOG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *OperLog) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.OperLog{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type operLogCloumns struct {
	ALL string

	Id            string
	Title         string
	BusinessType  string
	Method        string
	RequestMethod string
	ModuleType    string
	ModuleId      string
	OperatorType  string
	OperId        string
	OperName      string
	OperNickname  string
	OperUrl       string
	OperIp        string
	OperLocation  string
	OperParam     string
	OperMsg       string
	OperTimeAt    string
	CreatedAt     string
	UpdatedAt     string
	DeletedAt     string
	SpaceId       string
	ShowType      string
	SpaceName     string
	ModuleFlag    string
	raw           []string
}

var _operLogCloumns *operLogCloumns = &operLogCloumns{
	raw: []string{
		"id", "title", "business_type", "method", "request_method", "module_type", "module_id", "operator_type", "oper_id", "oper_name", "oper_nickname", "oper_url", "oper_ip", "oper_location", "oper_param", "oper_msg", "oper_time_at", "created_at", "updated_at", "deleted_at", "space_id", "show_type", "space_name", "module_flag",
	},
	ALL:           "*",
	Id:            "id",
	Title:         "title",
	BusinessType:  "business_type",
	Method:        "method",
	RequestMethod: "request_method",
	ModuleType:    "module_type",
	ModuleId:      "module_id",
	OperatorType:  "operator_type",
	OperId:        "oper_id",
	OperName:      "oper_name",
	OperNickname:  "oper_nickname",
	OperUrl:       "oper_url",
	OperIp:        "oper_ip",
	OperLocation:  "oper_location",
	OperParam:     "oper_param",
	OperMsg:       "oper_msg",
	OperTimeAt:    "oper_time_at",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	DeletedAt:     "deleted_at",
	SpaceId:       "space_id",
	ShowType:      "show_type",
	SpaceName:     "space_name",
	ModuleFlag:    "module_flag",
}

func (c *operLogCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *operLogCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkItemFlowV2 表结构
// 对应的 Proto 消息类型: SpaceWorkItemFlowV2
// 数据库表名: space_work_item_flow_v2
type SpaceWorkItemFlowV2 struct {
	Id                  int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	WorkItemId          int64  `gorm:"column:work_item_id" bson:"work_item_id" json:"work_item_id"`
	WorkItemRoleId      int64  `gorm:"column:work_item_role_id" bson:"work_item_role_id" json:"work_item_role_id"`
	WorkItemRoleKey     string `gorm:"column:work_item_role_key" bson:"work_item_role_key" json:"work_item_role_key"`
	FlowNodeUuid        string `gorm:"column:flow_node_uuid" bson:"flow_node_uuid" json:"flow_node_uuid"`
	FlowNodeStatus      int32  `gorm:"column:flow_node_status" bson:"flow_node_status" json:"flow_node_status"`
	FlowNodeCode        string `gorm:"column:flow_node_code" bson:"flow_node_code" json:"flow_node_code"`
	FlowNodePassed      int32  `gorm:"column:flow_node_passed" bson:"flow_node_passed" json:"flow_node_passed"`
	FlowNodeReached     int32  `gorm:"column:flow_node_reached" bson:"flow_node_reached" json:"flow_node_reached"`
	FlowModeVersion     string `gorm:"column:flow_mode_version" bson:"flow_mode_version" json:"flow_mode_version"`
	FlowModeCode        string `gorm:"column:flow_mode_code" bson:"flow_mode_code" json:"flow_mode_code"`
	StartAt             int64  `gorm:"column:start_at" bson:"start_at" json:"start_at"`
	FinishAt            int64  `gorm:"column:finish_at" bson:"finish_at" json:"finish_at"`
	Directors           string `gorm:"column:directors" bson:"directors" json:"directors"`
	CreatedAt           int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt           int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt           int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
	SpaceId             int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	PlanStartAt         int64  `gorm:"column:plan_start_at" bson:"plan_start_at" json:"plan_start_at"`
	PlanCompleteAt      int64  `gorm:"column:plan_complete_at" bson:"plan_complete_at" json:"plan_complete_at"`
	FlowId              int64  `gorm:"column:flow_id" bson:"flow_id" json:"flow_id"`
	FlowKey             string `gorm:"column:flow_key" bson:"flow_key" json:"flow_key"`
	FlowMode            string `gorm:"column:flow_mode" bson:"flow_mode" json:"flow_mode"`
	FlowTemplateId      int64  `gorm:"column:flow_template_id" bson:"flow_template_id" json:"flow_template_id"`
	FlowTemplateVersion int64  `gorm:"column:flow_template_version" bson:"flow_template_version" json:"flow_template_version"`
}

func (m *SpaceWorkItemFlowV2) TableName() string {
	return TableNamePrefix + "space_work_item_flow_v2"
}

func (m *SpaceWorkItemFlowV2) Cloumns() *spaceWorkItemFlowV2Cloumns {
	return _spaceWorkItemFlowV2Cloumns
}

func (m *SpaceWorkItemFlowV2) ToProto() *bean.SpaceWorkItemFlowV2 {
	return &bean.SpaceWorkItemFlowV2{
		Id:                  int64(m.Id),
		WorkItemId:          int64(m.WorkItemId),
		WorkItemRoleId:      int64(m.WorkItemRoleId),
		WorkItemRoleKey:     string(m.WorkItemRoleKey),
		FlowNodeUuid:        string(m.FlowNodeUuid),
		FlowNodeStatus:      int32(m.FlowNodeStatus),
		FlowNodeCode:        string(m.FlowNodeCode),
		FlowNodePassed:      int32(m.FlowNodePassed),
		FlowNodeReached:     int32(m.FlowNodeReached),
		FlowModeVersion:     string(m.FlowModeVersion),
		FlowModeCode:        string(m.FlowModeCode),
		StartAt:             int64(m.StartAt),
		FinishAt:            int64(m.FinishAt),
		Directors:           string(m.Directors),
		CreatedAt:           int64(m.CreatedAt),
		UpdatedAt:           int64(m.UpdatedAt),
		DeletedAt:           int64(m.DeletedAt),
		SpaceId:             int64(m.SpaceId),
		PlanStartAt:         int64(m.PlanStartAt),
		PlanCompleteAt:      int64(m.PlanCompleteAt),
		FlowId:              int64(m.FlowId),
		FlowKey:             string(m.FlowKey),
		FlowMode:            string(m.FlowMode),
		FlowTemplateId:      int64(m.FlowTemplateId),
		FlowTemplateVersion: int64(m.FlowTemplateVersion),
	}
}

func (m *SpaceWorkItemFlowV2) FromProto(proto *bean.SpaceWorkItemFlowV2) {
	m.Id = int64(proto.Id)
	m.WorkItemId = int64(proto.WorkItemId)
	m.WorkItemRoleId = int64(proto.WorkItemRoleId)
	m.WorkItemRoleKey = string(proto.WorkItemRoleKey)
	m.FlowNodeUuid = string(proto.FlowNodeUuid)
	m.FlowNodeStatus = int32(proto.FlowNodeStatus)
	m.FlowNodeCode = string(proto.FlowNodeCode)
	m.FlowNodePassed = int32(proto.FlowNodePassed)
	m.FlowNodeReached = int32(proto.FlowNodeReached)
	m.FlowModeVersion = string(proto.FlowModeVersion)
	m.FlowModeCode = string(proto.FlowModeCode)
	m.StartAt = int64(proto.StartAt)
	m.FinishAt = int64(proto.FinishAt)
	m.Directors = string(proto.Directors)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)
	m.SpaceId = int64(proto.SpaceId)
	m.PlanStartAt = int64(proto.PlanStartAt)
	m.PlanCompleteAt = int64(proto.PlanCompleteAt)
	m.FlowId = int64(proto.FlowId)
	m.FlowKey = string(proto.FlowKey)
	m.FlowMode = string(proto.FlowMode)
	m.FlowTemplateId = int64(proto.FlowTemplateId)
	m.FlowTemplateVersion = int64(proto.FlowTemplateVersion)

}

func (m *SpaceWorkItemFlowV2) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_ITEM_FLOW_V_2),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkItemFlowV2) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkItemFlowV2{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkItemFlowV2Cloumns struct {
	ALL string

	Id                  string
	WorkItemId          string
	WorkItemRoleId      string
	WorkItemRoleKey     string
	FlowNodeUuid        string
	FlowNodeStatus      string
	FlowNodeCode        string
	FlowNodePassed      string
	FlowNodeReached     string
	FlowModeVersion     string
	FlowModeCode        string
	StartAt             string
	FinishAt            string
	Directors           string
	CreatedAt           string
	UpdatedAt           string
	DeletedAt           string
	SpaceId             string
	PlanStartAt         string
	PlanCompleteAt      string
	FlowId              string
	FlowKey             string
	FlowMode            string
	FlowTemplateId      string
	FlowTemplateVersion string
	raw                 []string
}

var _spaceWorkItemFlowV2Cloumns *spaceWorkItemFlowV2Cloumns = &spaceWorkItemFlowV2Cloumns{
	raw: []string{
		"id", "work_item_id", "work_item_role_id", "work_item_role_key", "flow_node_uuid", "flow_node_status", "flow_node_code", "flow_node_passed", "flow_node_reached", "flow_mode_version", "flow_mode_code", "start_at", "finish_at", "directors", "created_at", "updated_at", "deleted_at", "space_id", "plan_start_at", "plan_complete_at", "flow_id", "flow_key", "flow_mode", "flow_template_id", "flow_template_version",
	},
	ALL:                 "*",
	Id:                  "id",
	WorkItemId:          "work_item_id",
	WorkItemRoleId:      "work_item_role_id",
	WorkItemRoleKey:     "work_item_role_key",
	FlowNodeUuid:        "flow_node_uuid",
	FlowNodeStatus:      "flow_node_status",
	FlowNodeCode:        "flow_node_code",
	FlowNodePassed:      "flow_node_passed",
	FlowNodeReached:     "flow_node_reached",
	FlowModeVersion:     "flow_mode_version",
	FlowModeCode:        "flow_mode_code",
	StartAt:             "start_at",
	FinishAt:            "finish_at",
	Directors:           "directors",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	DeletedAt:           "deleted_at",
	SpaceId:             "space_id",
	PlanStartAt:         "plan_start_at",
	PlanCompleteAt:      "plan_complete_at",
	FlowId:              "flow_id",
	FlowKey:             "flow_key",
	FlowMode:            "flow_mode",
	FlowTemplateId:      "flow_template_id",
	FlowTemplateVersion: "flow_template_version",
}

func (c *spaceWorkItemFlowV2Cloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkItemFlowV2Cloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkItemFlowRoleV2 表结构
// 对应的 Proto 消息类型: SpaceWorkItemFlowRoleV2
// 数据库表名: space_work_item_flow_role_v2
type SpaceWorkItemFlowRoleV2 struct {
	Id              int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId         int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	WorkItemId      int64  `gorm:"column:work_item_id" bson:"work_item_id" json:"work_item_id"`
	FlowId          int64  `gorm:"column:flow_id" bson:"flow_id" json:"flow_id"`
	FlowTemplateId  int64  `gorm:"column:flow_template_id" bson:"flow_template_id" json:"flow_template_id"`
	WorkItemRoleId  int64  `gorm:"column:work_item_role_id" bson:"work_item_role_id" json:"work_item_role_id"`
	WorkItemRoleKey string `gorm:"column:work_item_role_key" bson:"work_item_role_key" json:"work_item_role_key"`
	Directors       string `gorm:"column:directors" bson:"directors" json:"directors"`
	CreatedAt       int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt       int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt       int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceWorkItemFlowRoleV2) TableName() string {
	return TableNamePrefix + "space_work_item_flow_role_v2"
}

func (m *SpaceWorkItemFlowRoleV2) Cloumns() *spaceWorkItemFlowRoleV2Cloumns {
	return _spaceWorkItemFlowRoleV2Cloumns
}

func (m *SpaceWorkItemFlowRoleV2) ToProto() *bean.SpaceWorkItemFlowRoleV2 {
	return &bean.SpaceWorkItemFlowRoleV2{
		Id:              int64(m.Id),
		SpaceId:         int64(m.SpaceId),
		WorkItemId:      int64(m.WorkItemId),
		FlowId:          int64(m.FlowId),
		FlowTemplateId:  int64(m.FlowTemplateId),
		WorkItemRoleId:  int64(m.WorkItemRoleId),
		WorkItemRoleKey: string(m.WorkItemRoleKey),
		Directors:       string(m.Directors),
		CreatedAt:       int64(m.CreatedAt),
		UpdatedAt:       int64(m.UpdatedAt),
		DeletedAt:       int64(m.DeletedAt),
	}
}

func (m *SpaceWorkItemFlowRoleV2) FromProto(proto *bean.SpaceWorkItemFlowRoleV2) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.WorkItemId = int64(proto.WorkItemId)
	m.FlowId = int64(proto.FlowId)
	m.FlowTemplateId = int64(proto.FlowTemplateId)
	m.WorkItemRoleId = int64(proto.WorkItemRoleId)
	m.WorkItemRoleKey = string(proto.WorkItemRoleKey)
	m.Directors = string(proto.Directors)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceWorkItemFlowRoleV2) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_ITEM_FLOW_ROLE_V_2),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkItemFlowRoleV2) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkItemFlowRoleV2{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkItemFlowRoleV2Cloumns struct {
	ALL string

	Id              string
	SpaceId         string
	WorkItemId      string
	FlowId          string
	FlowTemplateId  string
	WorkItemRoleId  string
	WorkItemRoleKey string
	Directors       string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
	raw             []string
}

var _spaceWorkItemFlowRoleV2Cloumns *spaceWorkItemFlowRoleV2Cloumns = &spaceWorkItemFlowRoleV2Cloumns{
	raw: []string{
		"id", "space_id", "work_item_id", "flow_id", "flow_template_id", "work_item_role_id", "work_item_role_key", "directors", "created_at", "updated_at", "deleted_at",
	},
	ALL:             "*",
	Id:              "id",
	SpaceId:         "space_id",
	WorkItemId:      "work_item_id",
	FlowId:          "flow_id",
	FlowTemplateId:  "flow_template_id",
	WorkItemRoleId:  "work_item_role_id",
	WorkItemRoleKey: "work_item_role_key",
	Directors:       "directors",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
	DeletedAt:       "deleted_at",
}

func (c *spaceWorkItemFlowRoleV2Cloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkItemFlowRoleV2Cloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkItemComment 表结构
// 对应的 Proto 消息类型: SpaceWorkItemComment
// 数据库表名: space_work_item_comment
type SpaceWorkItemComment struct {
	Id             int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserId         int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	WorkItemId     int64  `gorm:"column:work_item_id" bson:"work_item_id" json:"work_item_id"`
	Content        string `gorm:"column:content" bson:"content" json:"content"`
	ReferUserIds   string `gorm:"column:refer_user_ids" bson:"refer_user_ids" json:"refer_user_ids"`
	ReplyCommentId int64  `gorm:"column:reply_comment_id" bson:"reply_comment_id" json:"reply_comment_id"`
	Emojis         string `gorm:"column:emojis" bson:"emojis" json:"emojis"`
	CreatedAt      int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt      int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt      int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceWorkItemComment) TableName() string {
	return TableNamePrefix + "space_work_item_comment"
}

func (m *SpaceWorkItemComment) Cloumns() *spaceWorkItemCommentCloumns {
	return _spaceWorkItemCommentCloumns
}

func (m *SpaceWorkItemComment) ToProto() *bean.SpaceWorkItemComment {
	return &bean.SpaceWorkItemComment{
		Id:             int64(m.Id),
		UserId:         int64(m.UserId),
		WorkItemId:     int64(m.WorkItemId),
		Content:        string(m.Content),
		ReferUserIds:   string(m.ReferUserIds),
		ReplyCommentId: int64(m.ReplyCommentId),
		Emojis:         string(m.Emojis),
		CreatedAt:      int64(m.CreatedAt),
		UpdatedAt:      int64(m.UpdatedAt),
		DeletedAt:      int64(m.DeletedAt),
	}
}

func (m *SpaceWorkItemComment) FromProto(proto *bean.SpaceWorkItemComment) {
	m.Id = int64(proto.Id)
	m.UserId = int64(proto.UserId)
	m.WorkItemId = int64(proto.WorkItemId)
	m.Content = string(proto.Content)
	m.ReferUserIds = string(proto.ReferUserIds)
	m.ReplyCommentId = int64(proto.ReplyCommentId)
	m.Emojis = string(proto.Emojis)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceWorkItemComment) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_ITEM_COMMENT),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkItemComment) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkItemComment{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkItemCommentCloumns struct {
	ALL string

	Id             string
	UserId         string
	WorkItemId     string
	Content        string
	ReferUserIds   string
	ReplyCommentId string
	Emojis         string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	raw            []string
}

var _spaceWorkItemCommentCloumns *spaceWorkItemCommentCloumns = &spaceWorkItemCommentCloumns{
	raw: []string{
		"id", "user_id", "work_item_id", "content", "refer_user_ids", "reply_comment_id", "emojis", "created_at", "updated_at", "deleted_at",
	},
	ALL:            "*",
	Id:             "id",
	UserId:         "user_id",
	WorkItemId:     "work_item_id",
	Content:        "content",
	ReferUserIds:   "refer_user_ids",
	ReplyCommentId: "reply_comment_id",
	Emojis:         "emojis",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
}

func (c *spaceWorkItemCommentCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkItemCommentCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// ThirdPfAccount 表结构
// 对应的 Proto 消息类型: ThirdPfAccount
// 数据库表名: third_pf_account
type ThirdPfAccount struct {
	Id            int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserId        int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	PfName        string `gorm:"column:pf_name" bson:"pf_name" json:"pf_name"`
	PfCode        int32  `gorm:"column:pf_code" bson:"pf_code" json:"pf_code"`
	PfUserKey     string `gorm:"column:pf_user_key" bson:"pf_user_key" json:"pf_user_key"`
	PfUserName    string `gorm:"column:pf_user_name" bson:"pf_user_name" json:"pf_user_name"`
	PfUserId      int64  `gorm:"column:pf_user_id" bson:"pf_user_id" json:"pf_user_id"`
	PfUserAccount string `gorm:"column:pf_user_account" bson:"pf_user_account" json:"pf_user_account"`
	Notify        int32  `gorm:"column:notify" bson:"notify" json:"notify"`
	CreatedAt     int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt     int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt     int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *ThirdPfAccount) TableName() string {
	return TableNamePrefix + "third_pf_account"
}

func (m *ThirdPfAccount) Cloumns() *thirdPfAccountCloumns {
	return _thirdPfAccountCloumns
}

func (m *ThirdPfAccount) ToProto() *bean.ThirdPfAccount {
	return &bean.ThirdPfAccount{
		Id:            int64(m.Id),
		UserId:        int64(m.UserId),
		PfName:        string(m.PfName),
		PfCode:        int32(m.PfCode),
		PfUserKey:     string(m.PfUserKey),
		PfUserName:    string(m.PfUserName),
		PfUserId:      int64(m.PfUserId),
		PfUserAccount: string(m.PfUserAccount),
		Notify:        int32(m.Notify),
		CreatedAt:     int64(m.CreatedAt),
		UpdatedAt:     int64(m.UpdatedAt),
		DeletedAt:     int64(m.DeletedAt),
	}
}

func (m *ThirdPfAccount) FromProto(proto *bean.ThirdPfAccount) {
	m.Id = int64(proto.Id)
	m.UserId = int64(proto.UserId)
	m.PfName = string(proto.PfName)
	m.PfCode = int32(proto.PfCode)
	m.PfUserKey = string(proto.PfUserKey)
	m.PfUserName = string(proto.PfUserName)
	m.PfUserId = int64(proto.PfUserId)
	m.PfUserAccount = string(proto.PfUserAccount)
	m.Notify = int32(proto.Notify)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *ThirdPfAccount) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_THIRD_PF_ACCOUNT),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *ThirdPfAccount) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.ThirdPfAccount{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type thirdPfAccountCloumns struct {
	ALL string

	Id            string
	UserId        string
	PfName        string
	PfCode        string
	PfUserKey     string
	PfUserName    string
	PfUserId      string
	PfUserAccount string
	Notify        string
	CreatedAt     string
	UpdatedAt     string
	DeletedAt     string
	raw           []string
}

var _thirdPfAccountCloumns *thirdPfAccountCloumns = &thirdPfAccountCloumns{
	raw: []string{
		"id", "user_id", "pf_name", "pf_code", "pf_user_key", "pf_user_name", "pf_user_id", "pf_user_account", "notify", "created_at", "updated_at", "deleted_at",
	},
	ALL:           "*",
	Id:            "id",
	UserId:        "user_id",
	PfName:        "pf_name",
	PfCode:        "pf_code",
	PfUserKey:     "pf_user_key",
	PfUserName:    "pf_user_name",
	PfUserId:      "pf_user_id",
	PfUserAccount: "pf_user_account",
	Notify:        "notify",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	DeletedAt:     "deleted_at",
}

func (c *thirdPfAccountCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *thirdPfAccountCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// Notify 表结构
// 对应的 Proto 消息类型: Notify
// 数据库表名: notify
type Notify struct {
	Id        int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId   int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	UserId    int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	Typ       int64  `gorm:"column:typ" bson:"typ" json:"typ"`
	Doc       string `gorm:"column:doc" bson:"doc" json:"doc"`
	CreatedAt int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *Notify) TableName() string {
	return TableNamePrefix + "notify"
}

func (m *Notify) Cloumns() *notifyCloumns {
	return _notifyCloumns
}

func (m *Notify) ToProto() *bean.Notify {
	return &bean.Notify{
		Id:        int64(m.Id),
		SpaceId:   int64(m.SpaceId),
		UserId:    int64(m.UserId),
		Typ:       int64(m.Typ),
		Doc:       string(m.Doc),
		CreatedAt: int64(m.CreatedAt),
		UpdatedAt: int64(m.UpdatedAt),
		DeletedAt: int64(m.DeletedAt),
	}
}

func (m *Notify) FromProto(proto *bean.Notify) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.UserId = int64(proto.UserId)
	m.Typ = int64(proto.Typ)
	m.Doc = string(proto.Doc)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *Notify) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_NOTIFY),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *Notify) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.Notify{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type notifyCloumns struct {
	ALL string

	Id        string
	SpaceId   string
	UserId    string
	Typ       string
	Doc       string
	CreatedAt string
	UpdatedAt string
	DeletedAt string
	raw       []string
}

var _notifyCloumns *notifyCloumns = &notifyCloumns{
	raw: []string{
		"id", "space_id", "user_id", "typ", "doc", "created_at", "updated_at", "deleted_at",
	},
	ALL:       "*",
	Id:        "id",
	SpaceId:   "space_id",
	UserId:    "user_id",
	Typ:       "typ",
	Doc:       "doc",
	CreatedAt: "created_at",
	UpdatedAt: "updated_at",
	DeletedAt: "deleted_at",
}

func (c *notifyCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *notifyCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceWorkVersion 表结构
// 对应的 Proto 消息类型: SpaceWorkVersion
// 数据库表名: space_work_version
type SpaceWorkVersion struct {
	Id            int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId       int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	VersionKey    string `gorm:"column:version_key" bson:"version_key" json:"version_key"`
	VersionName   string `gorm:"column:version_name" bson:"version_name" json:"version_name"`
	VersionStatus int64  `gorm:"column:version_status" bson:"version_status" json:"version_status"`
	Remark        string `gorm:"column:remark" bson:"remark" json:"remark"`
	Ranking       int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	CreatedAt     int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt     int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt     int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceWorkVersion) TableName() string {
	return TableNamePrefix + "space_work_version"
}

func (m *SpaceWorkVersion) Cloumns() *spaceWorkVersionCloumns {
	return _spaceWorkVersionCloumns
}

func (m *SpaceWorkVersion) ToProto() *bean.SpaceWorkVersion {
	return &bean.SpaceWorkVersion{
		Id:            int64(m.Id),
		SpaceId:       int64(m.SpaceId),
		VersionKey:    string(m.VersionKey),
		VersionName:   string(m.VersionName),
		VersionStatus: int64(m.VersionStatus),
		Remark:        string(m.Remark),
		Ranking:       int64(m.Ranking),
		CreatedAt:     int64(m.CreatedAt),
		UpdatedAt:     int64(m.UpdatedAt),
		DeletedAt:     int64(m.DeletedAt),
	}
}

func (m *SpaceWorkVersion) FromProto(proto *bean.SpaceWorkVersion) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.VersionKey = string(proto.VersionKey)
	m.VersionName = string(proto.VersionName)
	m.VersionStatus = int64(proto.VersionStatus)
	m.Remark = string(proto.Remark)
	m.Ranking = int64(proto.Ranking)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceWorkVersion) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_WORK_VERSION),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceWorkVersion) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceWorkVersion{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceWorkVersionCloumns struct {
	ALL string

	Id            string
	SpaceId       string
	VersionKey    string
	VersionName   string
	VersionStatus string
	Remark        string
	Ranking       string
	CreatedAt     string
	UpdatedAt     string
	DeletedAt     string
	raw           []string
}

var _spaceWorkVersionCloumns *spaceWorkVersionCloumns = &spaceWorkVersionCloumns{
	raw: []string{
		"id", "space_id", "version_key", "version_name", "version_status", "remark", "ranking", "created_at", "updated_at", "deleted_at",
	},
	ALL:           "*",
	Id:            "id",
	SpaceId:       "space_id",
	VersionKey:    "version_key",
	VersionName:   "version_name",
	VersionStatus: "version_status",
	Remark:        "remark",
	Ranking:       "ranking",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	DeletedAt:     "deleted_at",
}

func (c *spaceWorkVersionCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceWorkVersionCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// MemberCategory 表结构
// 对应的 Proto 消息类型: MemberCategory
// 数据库表名: member_category
type MemberCategory struct {
	Id        int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId   int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	Name      string `gorm:"column:name" bson:"name" json:"name"`
	Ranking   int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	CreatedAt int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt int64  `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *MemberCategory) TableName() string {
	return TableNamePrefix + "member_category"
}

func (m *MemberCategory) Cloumns() *memberCategoryCloumns {
	return _memberCategoryCloumns
}

func (m *MemberCategory) ToProto() *bean.MemberCategory {
	return &bean.MemberCategory{
		Id:        int64(m.Id),
		SpaceId:   int64(m.SpaceId),
		Name:      string(m.Name),
		Ranking:   int64(m.Ranking),
		CreatedAt: int64(m.CreatedAt),
		UpdatedAt: int64(m.UpdatedAt),
		DeletedAt: int64(m.DeletedAt),
	}
}

func (m *MemberCategory) FromProto(proto *bean.MemberCategory) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.Name = string(proto.Name)
	m.Ranking = int64(proto.Ranking)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *MemberCategory) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_MEMBER_CATEGORY),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *MemberCategory) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.MemberCategory{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type memberCategoryCloumns struct {
	ALL string

	Id        string
	SpaceId   string
	Name      string
	Ranking   string
	CreatedAt string
	UpdatedAt string
	DeletedAt string
	raw       []string
}

var _memberCategoryCloumns *memberCategoryCloumns = &memberCategoryCloumns{
	raw: []string{
		"id", "space_id", "name", "ranking", "created_at", "updated_at", "deleted_at",
	},
	ALL:       "*",
	Id:        "id",
	SpaceId:   "space_id",
	Name:      "name",
	Ranking:   "ranking",
	CreatedAt: "created_at",
	UpdatedAt: "updated_at",
	DeletedAt: "deleted_at",
}

func (c *memberCategoryCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *memberCategoryCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceMemberCategory 表结构
// 对应的 Proto 消息类型: SpaceMemberCategory
// 数据库表名: space_member_category
type SpaceMemberCategory struct {
	Id         int64 `gorm:"primaryKey" bson:"_id" json:"id"`
	CategoryId int64 `gorm:"column:category_id" bson:"category_id" json:"category_id"`
	SpaceId    int64 `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	UserId     int64 `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	Ranking    int64 `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	CreatedAt  int64 `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt  int64 `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
	DeletedAt  int64 `gorm:"column:deleted_at" bson:"deleted_at" json:"deleted_at"`
}

func (m *SpaceMemberCategory) TableName() string {
	return TableNamePrefix + "space_member_category"
}

func (m *SpaceMemberCategory) Cloumns() *spaceMemberCategoryCloumns {
	return _spaceMemberCategoryCloumns
}

func (m *SpaceMemberCategory) ToProto() *bean.SpaceMemberCategory {
	return &bean.SpaceMemberCategory{
		Id:         int64(m.Id),
		CategoryId: int64(m.CategoryId),
		SpaceId:    int64(m.SpaceId),
		UserId:     int64(m.UserId),
		Ranking:    int64(m.Ranking),
		CreatedAt:  int64(m.CreatedAt),
		UpdatedAt:  int64(m.UpdatedAt),
		DeletedAt:  int64(m.DeletedAt),
	}
}

func (m *SpaceMemberCategory) FromProto(proto *bean.SpaceMemberCategory) {
	m.Id = int64(proto.Id)
	m.CategoryId = int64(proto.CategoryId)
	m.SpaceId = int64(proto.SpaceId)
	m.UserId = int64(proto.UserId)
	m.Ranking = int64(proto.Ranking)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)
	m.DeletedAt = int64(proto.DeletedAt)

}

func (m *SpaceMemberCategory) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_MEMBER_CATEGORY),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceMemberCategory) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceMemberCategory{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceMemberCategoryCloumns struct {
	ALL string

	Id         string
	CategoryId string
	SpaceId    string
	UserId     string
	Ranking    string
	CreatedAt  string
	UpdatedAt  string
	DeletedAt  string
	raw        []string
}

var _spaceMemberCategoryCloumns *spaceMemberCategoryCloumns = &spaceMemberCategoryCloumns{
	raw: []string{
		"id", "category_id", "space_id", "user_id", "ranking", "created_at", "updated_at", "deleted_at",
	},
	ALL:        "*",
	Id:         "id",
	CategoryId: "category_id",
	SpaceId:    "space_id",
	UserId:     "user_id",
	Ranking:    "ranking",
	CreatedAt:  "created_at",
	UpdatedAt:  "updated_at",
	DeletedAt:  "deleted_at",
}

func (c *spaceMemberCategoryCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceMemberCategoryCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceGlobalView 表结构
// 对应的 Proto 消息类型: SpaceGlobalView
// 数据库表名: space_global_view
type SpaceGlobalView struct {
	Id          int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId     int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	Key         string `gorm:"column:key" bson:"key" json:"key"`
	Name        string `gorm:"column:name" bson:"name" json:"name"`
	Type        int64  `gorm:"column:type" bson:"type" json:"type"`
	QueryConfig string `gorm:"column:query_config" bson:"query_config" json:"query_config"`
	TableConfig string `gorm:"column:table_config" bson:"table_config" json:"table_config"`
	CreatedAt   int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt   int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
}

func (m *SpaceGlobalView) TableName() string {
	return TableNamePrefix + "space_global_view"
}

func (m *SpaceGlobalView) Cloumns() *spaceGlobalViewCloumns {
	return _spaceGlobalViewCloumns
}

func (m *SpaceGlobalView) ToProto() *bean.SpaceGlobalView {
	return &bean.SpaceGlobalView{
		Id:          int64(m.Id),
		SpaceId:     int64(m.SpaceId),
		Key:         string(m.Key),
		Name:        string(m.Name),
		Type:        int64(m.Type),
		QueryConfig: string(m.QueryConfig),
		TableConfig: string(m.TableConfig),
		CreatedAt:   int64(m.CreatedAt),
		UpdatedAt:   int64(m.UpdatedAt),
	}
}

func (m *SpaceGlobalView) FromProto(proto *bean.SpaceGlobalView) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.Key = string(proto.Key)
	m.Name = string(proto.Name)
	m.Type = int64(proto.Type)
	m.QueryConfig = string(proto.QueryConfig)
	m.TableConfig = string(proto.TableConfig)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)

}

func (m *SpaceGlobalView) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_GLOBAL_VIEW),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceGlobalView) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceGlobalView{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceGlobalViewCloumns struct {
	ALL string

	Id          string
	SpaceId     string
	Key         string
	Name        string
	Type        string
	QueryConfig string
	TableConfig string
	CreatedAt   string
	UpdatedAt   string
	raw         []string
}

var _spaceGlobalViewCloumns *spaceGlobalViewCloumns = &spaceGlobalViewCloumns{
	raw: []string{
		"id", "space_id", "key", "name", "type", "query_config", "table_config", "created_at", "updated_at",
	},
	ALL:         "*",
	Id:          "id",
	SpaceId:     "space_id",
	Key:         "key",
	Name:        "name",
	Type:        "type",
	QueryConfig: "query_config",
	TableConfig: "table_config",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
}

func (c *spaceGlobalViewCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceGlobalViewCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// SpaceUserView 表结构
// 对应的 Proto 消息类型: SpaceUserView
// 数据库表名: space_user_view
type SpaceUserView struct {
	Id          int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	SpaceId     int64  `gorm:"column:space_id" bson:"space_id" json:"space_id"`
	UserId      int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	Key         string `gorm:"column:key" bson:"key" json:"key"`
	Name        string `gorm:"column:name" bson:"name" json:"name"`
	Type        int64  `gorm:"column:type" bson:"type" json:"type"`
	OuterId     int64  `gorm:"column:outer_id" bson:"outer_id" json:"outer_id"`
	QueryConfig string `gorm:"column:query_config" bson:"query_config" json:"query_config"`
	TableConfig string `gorm:"column:table_config" bson:"table_config" json:"table_config"`
	Ranking     int64  `gorm:"column:ranking" bson:"ranking" json:"ranking"`
	Status      int64  `gorm:"column:status" bson:"status" json:"status"`
	CreatedAt   int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt   int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
}

func (m *SpaceUserView) TableName() string {
	return TableNamePrefix + "space_user_view"
}

func (m *SpaceUserView) Cloumns() *spaceUserViewCloumns {
	return _spaceUserViewCloumns
}

func (m *SpaceUserView) ToProto() *bean.SpaceUserView {
	return &bean.SpaceUserView{
		Id:          int64(m.Id),
		SpaceId:     int64(m.SpaceId),
		UserId:      int64(m.UserId),
		Key:         string(m.Key),
		Name:        string(m.Name),
		Type:        int64(m.Type),
		OuterId:     int64(m.OuterId),
		QueryConfig: string(m.QueryConfig),
		TableConfig: string(m.TableConfig),
		Ranking:     int64(m.Ranking),
		Status:      int64(m.Status),
		CreatedAt:   int64(m.CreatedAt),
		UpdatedAt:   int64(m.UpdatedAt),
	}
}

func (m *SpaceUserView) FromProto(proto *bean.SpaceUserView) {
	m.Id = int64(proto.Id)
	m.SpaceId = int64(proto.SpaceId)
	m.UserId = int64(proto.UserId)
	m.Key = string(proto.Key)
	m.Name = string(proto.Name)
	m.Type = int64(proto.Type)
	m.OuterId = int64(proto.OuterId)
	m.QueryConfig = string(proto.QueryConfig)
	m.TableConfig = string(proto.TableConfig)
	m.Ranking = int64(proto.Ranking)
	m.Status = int64(proto.Status)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)

}

func (m *SpaceUserView) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_SPACE_USER_VIEW),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *SpaceUserView) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.SpaceUserView{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type spaceUserViewCloumns struct {
	ALL string

	Id          string
	SpaceId     string
	UserId      string
	Key         string
	Name        string
	Type        string
	OuterId     string
	QueryConfig string
	TableConfig string
	Ranking     string
	Status      string
	CreatedAt   string
	UpdatedAt   string
	raw         []string
}

var _spaceUserViewCloumns *spaceUserViewCloumns = &spaceUserViewCloumns{
	raw: []string{
		"id", "space_id", "user_id", "key", "name", "type", "outer_id", "query_config", "table_config", "ranking", "status", "created_at", "updated_at",
	},
	ALL:         "*",
	Id:          "id",
	SpaceId:     "space_id",
	UserId:      "user_id",
	Key:         "key",
	Name:        "name",
	Type:        "type",
	OuterId:     "outer_id",
	QueryConfig: "query_config",
	TableConfig: "table_config",
	Ranking:     "ranking",
	Status:      "status",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
}

func (c *spaceUserViewCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *spaceUserViewCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

// -----------------------------------------------------------------------------
// UserConfig 表结构
// 对应的 Proto 消息类型: UserConfig
// 数据库表名: user_config
type UserConfig struct {
	Id        int64  `gorm:"primaryKey" bson:"_id" json:"id"`
	UserId    int64  `gorm:"column:user_id" bson:"user_id" json:"user_id"`
	Key       string `gorm:"column:key" bson:"key" json:"key"`
	Value     string `gorm:"column:value" bson:"value" json:"value"`
	CreatedAt int64  `gorm:"column:created_at" bson:"created_at" json:"created_at"`
	UpdatedAt int64  `gorm:"column:updated_at" bson:"updated_at" json:"updated_at"`
}

func (m *UserConfig) TableName() string {
	return TableNamePrefix + "user_config"
}

func (m *UserConfig) Cloumns() *userConfigCloumns {
	return _userConfigCloumns
}

func (m *UserConfig) ToProto() *bean.UserConfig {
	return &bean.UserConfig{
		Id:        int64(m.Id),
		UserId:    int64(m.UserId),
		Key:       string(m.Key),
		Value:     string(m.Value),
		CreatedAt: int64(m.CreatedAt),
		UpdatedAt: int64(m.UpdatedAt),
	}
}

func (m *UserConfig) FromProto(proto *bean.UserConfig) {
	m.Id = int64(proto.Id)
	m.UserId = int64(proto.UserId)
	m.Key = string(proto.Key)
	m.Value = string(proto.Value)
	m.CreatedAt = int64(proto.CreatedAt)
	m.UpdatedAt = int64(proto.UpdatedAt)

}

func (m *UserConfig) ToAnyObj() (*bean.AnyObj, error) {
	pbObj := m.ToProto()
	bytes, err := proto.Marshal(pbObj)
	if err != nil {
		return nil, err
	}
	body := bean.AnyObj{
		ObjType: uint32(bean.Table_USER_CONFIG),
		Obj:     bytes,
	}
	return &body, nil
}

func (m *UserConfig) FromAnyObj(anyObj *bean.AnyObj) error {
	pbObj := &bean.UserConfig{}
	err := proto.Unmarshal(anyObj.Obj, pbObj)
	if err != nil {
		return err
	}
	m.FromProto(pbObj)
	return nil
}

type userConfigCloumns struct {
	ALL string

	Id        string
	UserId    string
	Key       string
	Value     string
	CreatedAt string
	UpdatedAt string
	raw       []string
}

var _userConfigCloumns *userConfigCloumns = &userConfigCloumns{
	raw: []string{
		"id", "user_id", "key", "value", "created_at", "updated_at",
	},
	ALL:       "*",
	Id:        "id",
	UserId:    "user_id",
	Key:       "key",
	Value:     "value",
	CreatedAt: "created_at",
	UpdatedAt: "updated_at",
}

func (c *userConfigCloumns) Select(includes ...string) []string {
	if len(includes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range c.raw {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range includes {
		if _, isOk := m[v]; isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}

func (c *userConfigCloumns) SelectEx(excludes ...string) []string {
	if len(excludes) == 0 {
		return c.raw
	}

	m := make(map[string]bool)
	for _, i := range excludes {
		m[i] = true
	}

	clounms := make([]string, 0)
	for _, v := range c.raw {
		if _, isOk := m[v]; !isOk {
			clounms = append(clounms, v)
		}
	}

	if len(clounms) == 0 {
		return c.raw
	}
	return clounms
}
