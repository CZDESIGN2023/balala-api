# 開發規範

## table字段命名规范
- 主鍵命名: id
- 建立時間: create_at
  ```
  這兩個字段一定要遵守, 因為gorm自動生成的模板是一套共用的, 沒照著命名規則生成的code可能會有紅字
  ```
- 為了一致性, 其他常用時間欄位就用update_at和delete_at
- id和時間字段都用int64保存
- 如果一個字段有多個意思, 例如 1文本 2圖片..., 就在api層定義一個enum, 讀寫值避免直接寫數字, 用enum操作
- bit位操作的也要在api層用enum定義

## table註解
- 因為同時使用mysql和mongoDB, 所以麻煩大家要在mongoDB的table前加上[mongoDB]註解, 這樣自動生成工具才好判斷, 各自生成需要的struct
  ```
  // [mongoDB] 动态
  message TalkMoment {
    sint64 id = 1;
    ...
  }
  ```

## 共用組件
- 可共用的func請大家在utils擴充
- go的package是看目錄結構的, 所以utils內的那些檔案都是package utils
- 功能可以分檔撰寫, 不用都擠在同一個檔案內, utils.FuncName... 全都可以使用 (func name記得大寫開頭)
- 比較特別的功能組建可以在utils內再建一個目錄, 使用獨立的package名稱

## gorm [多字段]更新
- 不要使用struct填值, 要使用map[string]interface{}
- 原因請查看 4_常見問題說明.md (gorm多字段更新失敗)

## gorm where條件與err判斷
- where(使用First，Take，Last)查詢單筆資料時, 除了判斷err != nil應再判斷查回的record是否nil
- update或delete, 依照業務邏輯決定要不要判斷RowsAffected
- where(Find)查詢多筆資料時, 依照業務邏輯決定要不要判斷資料筆數
- 原因請查看 4_常見問題說明.md (gorm where條件 ...)

## 常用功能
- 鎖: 常用的有互斥鎖sync.Mutex(讀寫平均時使用)、讀寫鎖sync.RWMutex(讀多於寫的時候使用)
- 緩存: 可參考data/config.go, 裡面有使用三種不同的cache, 1. map搭配鎖, 2.localCache, 3. redis cache, 視情況選擇
  ```
    1. map搭配鎖
    cacheConfig map[string]*db.Config
  
    2. localCache (共用的localCache已經改為各自獨立new的泛型cache, 內部已經包裝過鎖)
    cacheConfig := local_cache.NewCache[string, *db.Config](-1) // 永不過期
    cacheConfig := local_cache.NewCache[string, *db.Config](time.Hour * 24) // 24小時過期
    取值後不用轉型:
    dbConfig, found := cacheConfig.Get(key)
    
    3. redis
    repo.CacheGetObj
    repo.CacheSetObj
    ...
  
    取出值後需要轉型成當初存入的結構, 使用以下方法:
    cacheObj, err := repo.CacheGetObj(ctx, key, &db.Config{})
	dbConfig, _ := cacheObj.(*db.Config) // 第二個參數取值不可省略, 避免轉型出錯時發生panic導致程式中斷
    
    p.s: 目前發現array存取可能有問題, 還要再測試看看, 或許要改寫一下CacheGetObj改為回傳[]byte, 外部收到再自行json.Unmarshal
  ```